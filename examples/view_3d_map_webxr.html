<!DOCTYPE html>
<html>
    <head>
        <title>Itowns - WebXR Example</title>

        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link rel="stylesheet" type="text/css" href="css/example.css">
    </head>
    <body>
        <div id="viewerDiv"></div>

        <script type="importmap">
            {
                "imports": {
                    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/"
                }
            }
        </script>

        <!-- Import iTowns source code -->
        <script src="../dist/itowns.js"></script>

        <script type="module">

            import { VRButton } from 'three/addons/webxr/VRButton.js';

            // ---------- SETUP THE VR VIEW : ----------

            // Define camera initial position
            const placement = {
                coord: new itowns.Coordinates('EPSG:4326', 6.227, 45.167),
                range: 15000,
                tilt: 5,
                heading: 62,
            }

            // `viewerDiv` will contain iTowns' rendering area (`<canvas>`)
            const viewerDiv = document.getElementById('viewerDiv');
            const contextXR = {
                tempMatrix: new itowns.THREE.Matrix4(),
                coordOnCamera: {},
                deltaRotation: 0,
                interactiveLayers : []
            };

            const scale = 1;

            // Create a GlobeView
                webXR: { scale: scale, 
                    callback: render},
                
            const view = new itowns.GlobeView(viewerDiv, placement, { webXR: { scale: scale, callback: render } });

            // Instantiate three's VR Button
            const vrButton = VRButton.createButton(view.renderer);
            viewerDiv.appendChild(vrButton);

            // Setup loading screen and debug menu
            setupLoadingScreen(viewerDiv, view);
            var debugMenu = new GuiTools('menuDiv', view);


            // ---------- DISPLAY ORTHO-IMAGES : ----------

            // Add one imagery layer to the scene. This layer's properties are
            // defined in a json file, but it could be defined as a plain js
            // object. See `Layer` documentation for more info.
            itowns.Fetcher.json('./layers/JSONLayers/Ortho.json').then((config) => {
                config.source = new itowns.WMTSSource(config.source);
                view.addLayer(
                    new itowns.ColorLayer('Ortho', config),
                ).then(debugMenu.addLayerGUI.bind(debugMenu));
            });

            // ---------- DISPLAY A DIGITAL ELEVATION MODEL : ----------

            // Add two elevation layers, each with a different level of detail.
            // Here again, each layer's properties are defined in a json file.
            function addElevationLayerFromConfig(config) {
                config.source = new itowns.WMTSSource(config.source);
                contextXR.elevationLayer = new itowns.ElevationLayer(config.id, config);
                view.addLayer(contextXR.elevationLayer).then(debugMenu.addLayerGUI.bind(debugMenu));
            }


            // ------------- webxr interaction ----------------
            view.scene.matrixWorldAutoUpdate = true;
            
            addControllers();

            function getGeodesicalQuaternion() {
                //TODO can be optimized with better cache
                const position = view.controls.getCameraCoordinate().clone().as(view.referenceCrs);
                const geodesicNormal = new itowns.THREE.Quaternion().setFromUnitVectors(new itowns.THREE.Vector3(0, 0, 1), position.geodesicNormal).invert();
                return new itowns.THREE.Quaternion(-1, 0, 0, 1).normalize().multiply(geodesicNormal);
            }

            function addFakeRoom() {
                contextXR.raycaster = new itowns.THREE.Raycaster();

                var cameraTargetPosition = view.controls.getCameraCoordinate().clone();
                var meshCoord =  new itowns.Coordinates(cameraTargetPosition.crs, cameraTargetPosition.x, cameraTargetPosition.y, cameraTargetPosition.z );
                meshCoord.altitude -= 10050;

                contextXR.raycaster.ray.origin.copy(meshCoord.as(view.referenceCrs));
                contextXR.floor = new itowns.THREE.Mesh(
					new itowns.THREE.PlaneGeometry( 10000, 10000, 1, 1 ),
					new itowns.THREE.MeshBasicMaterial( { color: 0x222222, side: itowns.THREE.DoubleSide } )
				);
                contextXR.floor.name = "floor";
                // position and orientation of the mesh
                contextXR.floor.position.copy(meshCoord.as(view.referenceCrs));
                contextXR.floor.lookAt(new itowns.THREE.Vector3(0, 0, 0));

                // update coordinate of the mesh
                contextXR.floor.updateMatrixWorld();
                // add the mesh to the scene
                view.scene.add(contextXR.floor);

                meshCoord.altitude += 1;
                contextXR.marker = new itowns.THREE.Mesh(
					new itowns.THREE.CircleGeometry( 50, 32 ),
					new itowns.THREE.MeshBasicMaterial( { color: 0xbcbcbc, side: itowns.THREE.DoubleSide } )
				);
                contextXR.marker.position.copy(meshCoord.as(view.referenceCrs));
                contextXR.marker.lookAt(new itowns.THREE.Vector3(0, 0, 0));
                contextXR.marker.name = "marker";
                contextXR.marker.updateMatrixWorld();
				view.scene.add(contextXR.marker);

                view.notifyChange();
            }

            function loadBuildingGltf() {
                                // Load a glTF resource
                                itowns.glTFLoader.load(
                // resource URL, do not commit as is.
                "myGLB.glb",

                
                // called when the resource is loaded
                (gltf) => {
                    gltf.scene.position.copy(new itowns.THREE.Vector3(4486191.121470811, 477820.22721133975, 4495989.354518597));
                    
                    gltf.scene.lookAt(new itowns.THREE.Vector3(0, 0, 0));
                    gltf.scene.rotateX(Math.PI / 2);
                    gltf.scene.rotateX(Math.PI);

                    // update coordinate of the mesh
                    gltf.scene.updateMatrixWorld();
                    const gltfBbox = new itowns.THREE.Box3();
                    gltfBbox.setFromObject(gltf.scene);
                    
                    view.scene.add(gltf.scene);
                    const helper = new itowns.THREE.Box3Helper( gltfBbox, 0xffff00 );
                    helper.name="bboxGltfHelper";
                    helper.visible = false;
                    view.scene.add(helper);
                    var gltfBox = generateVRBox(gltf.scene);
                    applyGltfBoxToCHilds(gltf.scene, gltfBox);
                    contextXR.interactiveLayers.push(gltf.scene);
                    gltf.VRBbox = helper;
                    view.notifyChange();
                },
                // called while loading is progressing
                () => {},
                // called when loading has errors
                (error) => {
                    // eslint-disable-next-line no-console
                    console.log("An error happened :");
                    // eslint-disable-next-line no-console
                    console.log(error);
                });

                function applyGltfBoxToCHilds(gltfScene, gltfBox) {
                    gltfScene.traverse(o => {
                        o.VRBbox = gltfBox;
                    });
                }
            }
                

            function addControllers() {

                contextXR.renderer = view.mainLoop.gfxEngine.renderer;
                 contextXR.controller1 = bindListeners(0);
                 contextXR.controller2 = bindListeners(1);
                 contextXR.controller1.addEventListener('itowns-xr-axes-changed', onLeftAxisChanged);
                 contextXR.controller2.addEventListener('itowns-xr-axes-changed', onRightAxisChanged);
                 contextXR.controller2.addEventListener('itowns-xr-axes-stop', onRightAxisStop);
                 contextXR.controller2.addEventListener('itowns-xr-button-pressed', onRightButtonPressed);
                 

                 contextXR.renderer.xr.addEventListener( 'sessionstart', function ()
                 {
                    contextXR.baseReferenceSpace = contextXR.renderer.xr.getReferenceSpace();
                    view.scene.children.forEach((child) => {if(child.name === 'xrHeadset') { contextXR.xrHeadSet = child;} });
                    addFakeRoom();
                 });

                function bindListeners(index) {
                    const controller = contextXR.renderer.xr.getController(index);
                    controller.addEventListener( 'selectstart', onSelectStart );
                    controller.addEventListener( 'selectend', onSelectEnd );
                    return controller;
                }

                function onSelectStart() {
                    this.userData.isSelecting = true;
                }

                function onSelectEnd() {
                    this.userData.isSelecting = false;
					if ( contextXR.coordOnCamera ) {
                        const offsetRotation = getGeodesicalQuaternion();
                        const projectedCoordinate = contextXR.coordOnCamera.as(view.referenceCrs);
                        showPosition('intersect', projectedCoordinate, 0x0000ff);
                        // reset continuous translation applied to headSet parent.
                        contextXR.xrHeadSet.position.copy(new itowns.THREE.Vector3());


                       // compute targeted position relative to the origine camera.
                        const trans = new itowns.THREE.Vector3(projectedCoordinate.x, projectedCoordinate.y, projectedCoordinate.z).multiplyScalar(-1).applyQuaternion(offsetRotation); // TODO apply quat to
                        const transform = new XRRigidTransform( trans, offsetRotation );
                        const teleportSpaceOffset = contextXR.baseReferenceSpace.getOffsetReferenceSpace( transform );
                        contextXR.renderer.xr.setReferenceSpace( teleportSpaceOffset );
                    }
                }
 
                function onRightButtonPressed(data) {
                    if (data.target.name !== 'rightController') {
                        return;
                    }
                    var ctrl = data.message.controller;
                    if (data.message.buttonIndex === 1) {
                        // activate vertical adjustment
                        udpateCameraElevationLive(ctrl);
                    }
                }

                // rotation controls
                function onLeftAxisChanged(data) {
                    if (data.target.name !== 'leftController') {
                        return;
                    }
                    var ctrl = data.message.controller;
                    if ( contextXR.INTERSECTION ) {
                        
                    } else {
                        applyRotation(ctrl);
                    } 
                }

                
                function applyRotation(ctrl) {
                    if(ctrl.gamepad.axes[2] === 0) {
                        return;
                    }
                    contextXR.deltaRotation += Math.PI / (160 * ctrl.gamepad.axes[2]);
                    const offsetRotation = getGeodesicalQuaternion();
					var thetaRotMatrix = new itowns.THREE.Matrix4().identity().makeRotationY(contextXR.deltaRotation);
                    var rotationQuartenion = new itowns.THREE.Quaternion().setFromRotationMatrix(thetaRotMatrix).normalize();
                    offsetRotation.premultiply(rotationQuartenion);
                    const trans = view.camera.camera3D.position.clone().multiplyScalar(-1).applyQuaternion(offsetRotation);
					const transform = new XRRigidTransform( trans, offsetRotation );
					const teleportSpaceOffset = contextXR.baseReferenceSpace.getOffsetReferenceSpace( transform );
					contextXR.renderer.xr.setReferenceSpace( teleportSpaceOffset );
                }

                function udpateCameraElevationLive(ctrl) {
                    if(ctrl.gamepad.axes[3] === 0) {
                        return;
                    }
                    var speed = ctrl.gamepad.axes[3] * 100;
                    var direction = view.controls.getCameraCoordinate().geodesicNormal.clone();
                    direction.multiplyScalar(-speed);
                    contextXR.xrHeadSet.position.add(direction);
                }

                // translation controls
                function onRightAxisChanged(data) {
                    if (data.target.name !== 'rightController') {
                        return;
                    }
                    var ctrl = data.message.controller;
                    if (ctrl.lockButtonIndex) {
                        return;
                    }
                    if ( contextXR.INTERSECTION ) {
                        //updating elevation at intersection destination
                        contextXR.deltaAltitude -= ctrl.gamepad.axes[3] * 100;
                    } else {
                        cameraOnFly(ctrl);
                    }
                }

                function cameraOnFly(ctrl) {
                    if (!ctrl.flyDirectionMatrix) {
                        // locking camera look at
                        var matrixHeadset = new itowns.THREE.Matrix4();
                        matrixHeadset.identity().extractRotation( view.camera.camera3D.matrixWorld );
                        ctrl.flyDirectionMatrix = matrixHeadset;
                    }
                    if (ctrl.gamepad.axes[2] === 0 && ctrl.gamepad.axes[3] === 0) {
                        return;
                    }
                    var directionX = new itowns.THREE.Vector3();
                    var directionY = new itowns.THREE.Vector3();

                    if (ctrl.gamepad.axes[3] !== 0) {
                        // flying following the locked camera look at
                        // TODO itowns.camera.adjustAltitudeToAvoidCollisionWithLayer() to avoid collision
                        var speed = ctrl.gamepad.axes[3] * 100;
                        
                        directionY = new itowns.THREE.Vector3(0,0,1).applyMatrix4(ctrl.flyDirectionMatrix).multiplyScalar(speed);
                    } 
                    if (ctrl.gamepad.axes[2] !== 0) {
                        var speed = ctrl.gamepad.axes[2] * 100;
                        
                        directionX = new itowns.THREE.Vector3(1,0,0).applyMatrix4(ctrl.flyDirectionMatrix).multiplyScalar(speed);
                        
                    }
                    contextXR.xrHeadSet.position.add(directionX.add(directionY));
                }

                function onRightAxisStop(data) {
                    // camera fly reset
                    data.message.controller.flyDirectionMatrix = undefined;
                }
            }

            function showPosition(name, coordinates, color, radius = 50) {
                var existingChild;
                    view.scene.children.forEach((child) => {if(child.name === name) { existingChild = child;} });

                    if(existingChild) {
                        existingChild.position.copy(coordinates);
                    }
                    else {
                        const previousPos = new itowns.THREE.Mesh(
					        new itowns.THREE.SphereGeometry( radius, 16, 8 ),
					        new itowns.THREE.MeshBasicMaterial( { color: color, wireframe: true } )
				        );
                        previousPos.name = name;
                        previousPos.position.copy(coordinates);
                        view.scene.add(previousPos);
                        existingChild = previousPos;
                    }
                    return existingChild;
                }

                function showPositionVerticalLine(name, coordinates, color, upSize) {
                    var existingChild;
                    view.scene.children.forEach((child) => {if(child.name === name) { existingChild = child;} });

                    if(existingChild) {
                        existingChild.position.copy(coordinates);
                    }
                    else {
                        const points = [];
                        points.push(new itowns.THREE.Vector3(0,0,0));
                        // upward direction
                        points.push(new itowns.THREE.Vector3(0, 0, -upSize));

                        const line = new itowns.THREE.Line(
                            new itowns.THREE.BufferGeometry().setFromPoints(points),
                            new itowns.THREE.LineBasicMaterial({ color: color }));
                        line.position.copy(coordinates);
                        //necessary to "look" vertically
                        line.lookAt(new itowns.THREE.Vector3(0, 0, 1));
                        line.name = name;
                        view.scene.add(line);
                    }

                }

            function renderdirectionArrow(name, originVector3, directionVector3, scale, color) {
                var existingChild;
                view.scene.children.forEach((child) => {if(child.name === name) { existingChild = child;} });
                if(existingChild) {
                    existingChild.setDirection(directionVector3);
                    existingChild.origin = originVector3;
                }
                else {
                    const arrow = new itowns.THREE.ArrowHelper(directionVector3, originVector3, scale, color);
                    arrow.name = name;
                    view.scene.add(arrow);
                }   
            }

            function updateBboxVisibility(object) {
                if(contextXR.visibleBbox === object){
                    return;
                }
                // proper to box3Helper
                if(object.box) { 
                    if (!object.visible) {
                        console.log('im still using this?');
                        resetPreviousVisibleeBbox();
                        contextXR.visibleBbox = object;
                        object.visible = true;
                    }
                }
                else if(object.geometry) {
                    if(!object.VRBbox) {
                        generateVRBox(object);
                    }
                    if (!object.VRBbox.visible) {
                        resetPreviousVisibleeBbox();
                        contextXR.visibleBbox = object.VRBbox;
                        object.VRBbox.visible = true;
                    }
                } else if(contextXR.visibleBbox) {
                    resetPreviousVisibleeBbox();
                }

                function resetPreviousVisibleeBbox() {
                    if(contextXR.visibleBbox) {
                        contextXR.visibleBbox.visible = false;
                        contextXR.visibleBbox = undefined;
                    }
                }
            }

            function generateVRBox(object) {
                const objectBbox = new itowns.THREE.Box3();
                // better than object.geometry.computeBoundingBox(); as it copy parent position.
                objectBbox.setFromObject(object);
                object.VRBbox = objectBbox;
                object.VRBbox = new itowns.THREE.Box3Helper(object.VRBbox, 0xffff00);

                object.VRBbox.name = object.name +'_VRBbox';
                view.scene.add(object.VRBbox);
                object.VRBbox.visible = false;
                return object.VRBbox;
            }
        
            function intersectInteractiveLayers() {
                // test intersection coordinate with terrain
                contextXR.tempMatrix.identity().extractRotation(contextXR.controller2.matrixWorld);
                contextXR.raycaster.ray.origin.setFromMatrixPosition(contextXR.controller2.matrixWorld);
                contextXR.raycaster.ray.direction.set(0, 0, -1).applyMatrix4( contextXR.tempMatrix);
                return contextXR.raycaster.intersectObjects(contextXR.interactiveLayers);
            }

            function render() {
                contextXR.INTERSECTION = undefined;
                const intersects = intersectInteractiveLayers(); 
                if ( intersects.length > 0 ) {
                    updateBboxVisibility(intersects[0].object);
                    if ( contextXR.controller2.userData.isSelecting === true ) {
                        contextXR.INTERSECTION = intersects[ 0 ].point;
                    }
                } else if (contextXR.visibleBbox) {
                    contextXR.visibleBbox.visible = false;
                    contextXR.visibleBbox = undefined;
                }

                if ( contextXR.INTERSECTION )
                {

                   var intersectionCoord = new itowns.Coordinates(view.referenceCrs, contextXR.INTERSECTION.x, contextXR.INTERSECTION.y, contextXR.INTERSECTION.z);
                   var justElevationAt = itowns.DEMUtils.getElevationValueAt(view.tileLayer,  view.controls.getCameraCoordinate().clone(), itowns.DEMUtils.PRECISE_READ_Z);

                   // not a {itowns.Coordinates} 
                    var coordOnCamera = itowns.DEMUtils.getTerrainObjectAt(view.tileLayer, intersectionCoord, itowns.DEMUtils.PRECISE_READ_Z);
                    if (contextXR.coordOnCamera && contextXR.deltaAltitude) {
                        coordOnCamera.coord.altitude += contextXR.deltaAltitude;
                    } else {
                         // by default set altitude to the current camera elevation from terrain
                         let cameraCoordOnTerrain = itowns.DEMUtils.getTerrainObjectAt(view.tileLayer, view.controls.getCameraCoordinate().clone(), itowns.DEMUtils.PRECISE_READ_Z);
                         coordOnCamera.coord.altitude += cameraCoordOnTerrain.coord.z;
                         contextXR.deltaAltitude = cameraCoordOnTerrain.coord.z;
                    }
                    
                    // must clone Coordinate to avoid side effect, maybe with DEMUtils, but not sure.
                    contextXR.coordOnCamera = new itowns.Coordinates(coordOnCamera.coord.crs);
                    contextXR.coordOnCamera.setFromVector3(coordOnCamera.coord);

                    var cameraFloorIntersect = view.controls.getCameraCoordinate().clone();
                    // FIXME result is not stricly the camera position as expected, maybe due to the intersection position?
                    // FIXME getCameraCoordinate doesn't update on webxr camera move, maybe test it in "unbounded" / "bounded" context
                    var cameraTargetPosition = view.controls.getCameraCoordinate().clone();
                    /* the staircase effect find explanation in regard of view.camera.camera3D.position z evolution
                    for some reason, position is highly rounded when not to initial vr pos.
                    but camera matrices seems like in the same level of definition...
                    */
                    cameraFloorIntersect.altitude = justElevationAt;

                    showPosition('findMe', intersectionCoord, 0xfeff00, 5500);
                    showPosition('findMePRECISE',  contextXR.coordOnCamera.as(view.referenceCrs), 0xaffb00, 100);
                    showPosition('findMeCamera', cameraFloorIntersect.as(view.referenceCrs), 0x44aaff, 100);
                    
                    showPositionVerticalLine('findMe2', intersectionCoord, 0xfe0c00, 10000);
                    // FIXME position on the ground as an unknown delta... find why

                    // showing camera floor intersection
                    contextXR.marker.position.copy(cameraFloorIntersect.as(view.referenceCrs));

                    
                    view.meshPointer.position.copy(intersectionCoord);
                } else {
                    // if no more intersection, reset coords.
                    contextXR.coordOnCamera = undefined;
                }
                contextXR.marker.visible = contextXR.INTERSECTION !== undefined;
            }


            //---------  add fake to ground

            function addMeshToScene() {
                // creation of the new mesh (a cylinder)
                var THREE = itowns.THREE;
                var geometry = new THREE.CylinderGeometry(0, 10, 60, 8);
                var material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                var meshPointer = new THREE.Mesh(geometry, material);

                // get the position on the globe, from the camera
                var cameraTargetPosition = view.controls.getLookAtCoordinate();

                // position of the mesh
                var meshCoord = cameraTargetPosition.clone();
                meshCoord.altitude += 30;

                // position and orientation of the mesh
                meshPointer.position.copy(meshCoord.as(view.referenceCrs));
                meshPointer.lookAt(new THREE.Vector3(0, 0, 0));
                meshPointer.rotateX(Math.PI / 2);

                // update coordinate of the mesh
                meshPointer.updateMatrixWorld();

                // add the mesh to the scene
                view.scene.add(meshPointer);

                // make the object usable from outside of the function
                view.meshPointer = meshPointer;
                view.notifyChange();
            }

            // Listen for globe full initialisation event
            view.addEventListener(itowns.GLOBE_VIEW_EVENTS.GLOBE_INITIALIZED, function globeInitialized() {
                // eslint-disable-next-line no-console
                console.info('Globe initialized');


               addMeshToScene();
            });

            var d = new debug.Debug(view, debugMenu.gui);
            debug.createTileDebugUI(debugMenu.gui, view, view.tileLayer, d);

            itowns.Fetcher.json('./layers/JSONLayers/IGN_MNT_HIGHRES.json').then(addElevationLayerFromConfig);
            itowns.Fetcher.json('./layers/JSONLayers/WORLD_DTM.json').then(addElevationLayerFromConfig);

        </script>
    </body>
</html>
