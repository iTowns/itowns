<!DOCTYPE html>
<html>
    <head>
        <title>Itowns - WebXR Example</title>

        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link rel="stylesheet" type="text/css" href="css/example.css">
        <link rel="stylesheet" type="text/css" href="css/LoadingScreen.css">
        <link rel="stylesheet" type="text/css" href="css/widgets.css">

        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js"></script>																
																	  

																																												
    </head>
    <body>
        <div id="viewerDiv"></div>

        <script type="importmap">
            {
                "imports": {
                    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/"
                }
            }
        </script>

        <!-- Import iTowns source code -->
        <script src="../dist/itowns.js"></script>
        <script src="../dist/debug.js"></script>
        <!-- Import iTowns Widgets plugin -->
        <script src="../dist/itowns_widgets.js"></script>
        <!-- Import iTowns LoadingScreen and GuiTools plugins -->
        <script src="js/GUI/GuiTools.js"></script>
        <script src="js/GUI/LoadingScreen.js"></script>
        <script src="js/XR/Controllers.js"></script>
        <script src="js/XR/Utils.js"></script>

        <script type="module">
            import { VRButton } from 'three/addons/webxr/VRButton.js';
            // ---------- CREATE A GlobeView FOR SUPPORTING DATA VISUALIZATION : ----------
            const tile3DCoordinates = new itowns.Coordinates('EPSG:4978', 4413284.5, -18949.275390625, 4589538.5); // 4412106.042879028, -26370.61912189091, 4590341.467693916);
            const mountainsCoordinates = new itowns.Coordinates('EPSG:4326', 6.227, 45.167);

            // ---------- SETUP THE VR VIEW : ----------

            // Define camera initial position
            const placement = {
                coord: tile3DCoordinates,
                range: 1000,
                tilt: 5,
                heading: 110,
                /**
                range: 15000,
                tilt: 5,
                heading: 62,
                */
            };



            // `viewerDiv` will contain iTowns' rendering area (`<canvas>`)
            const viewerDiv = document.getElementById('viewerDiv');
            const contextXR = {
                showDebug: false, // used by /js/XR/Utils.js
                tempMatrix: new itowns.THREE.Matrix4(),
                coordOnCamera: {},
                interactiveLayers : [],
                secondCamera: { renderTarget: new itowns.THREE.WebGLRenderTarget(512, 512) }
            };

            const scale = 1;

            // Create a GlobeView
            const view = new itowns.GlobeView(viewerDiv, placement, { webXR: { scale: scale, callback: render } }); 

            // Instantiate three's VR Button
            const vrButton = VRButton.createButton(view.renderer);
            viewerDiv.appendChild(vrButton);

            // Setup loading screen and debug menu
            setupLoadingScreen(viewerDiv, view);
            var menuGlobe = new GuiTools('menuDiv', view, 300);
            
            // ---------- DISPLAY ORTHO-IMAGES : ----------

            // Add one imagery layer to the scene. This layer's properties are
            // defined in a json file, but it could be defined as a plain js
            // object. See `Layer` documentation for more info.
            itowns.Fetcher.json('./layers/JSONLayers/Ortho.json').then((config) => {
                config.source = new itowns.WMTSSource(config.source);
                view.addLayer(
                    new itowns.ColorLayer('Ortho', config),
                ).then(menuGlobe.addLayerGUI.bind(menuGlobe));
            });



            // Create a new Layer 3d-tiles For Pointcloud
            // -------------------------------------------
            contextXR.pointLayer = new itowns.C3DTilesLayer('3d-tiles-geredis', {
                name: 'geredis',
                sseThreshold: 5,
                pntsMode: itowns.PNTS_MODE.CLASSIFICATION,
                pntsSizeMode:1,
                pntsMinAttenuatedSize: 1,
                pntsMaxAttenuatedSize: 1000,
                source: new itowns.C3DTilesSource({
                    url: 'https://10.1.23.22/3dtiles/demo_point_cloud/tileset.json',
                }),
                classification : {
                    0: { visible: true, name: 'never classified', color: new itowns.THREE.Color(0.5,  0.5,  0.5), opacity: 1.0 },
                    1: { visible: true, name: 'unclassified', color: new itowns.THREE.Color(0.5,  0.5,  0.5), opacity: 1.0 },
                    2: { visible: true, name: 'ground', color: new itowns.THREE.Color(0.63, 0.32, 0.18), opacity: 0.0 },
                    3: { visible: true, name: 'low vegetation', color: new itowns.THREE.Color(0.0,  1.0,  0.0), opacity: 1.0 },
                    4: { visible: true, name: 'medium vegetation', color: new itowns.THREE.Color(0.0,  0.8,  0.0), opacity: 1.0 },
                    5: { visible: true, name: 'high vegetation', color: new itowns.THREE.Color(0.0,  0.6,  0.0), opacity: 1.0 },
                    6: { visible: true, name: 'building', color: new itowns.THREE.Color(1.0,  0.66, 0.0), opacity: 1.0 },
                    7: { visible: true, name: 'low point(noise)', color: new itowns.THREE.Color(1.0,  0.0,  1.0), opacity: 1.0 },
                    8: { visible: true, name: 'key-point', color: new itowns.THREE.Color(1.0,  0.0,  0.0), opacity: 1.0 },
                    9: { visible: true, name: 'water', color: new itowns.THREE.Color(0.0,  0.0,  1.0), opacity: 1.0 },
                    10: { visible: true, name: 'rail', color: new itowns.THREE.Color(0.8,  0.8,  1.0), opacity: 1.0 },
                    11: { visible: true, name: 'road Surface', color: new itowns.THREE.Color(0.4,  0.4,  0.7), opacity: 1.0 },
                    12: { visible: true, name: 'overlap', color: new itowns.THREE.Color(1.0,  1.0,  0.0), opacity: 1.0 },
                    DEFAULT: { visible: true, name: 'default', color: new itowns.THREE.Color(0.3,  0.6,  0.6), opacity: 0.5 },
                },
            }, view);

            contextXR.pointLayer.addEventListener(
                itowns.C3DTILES_LAYER_EVENTS.ON_TILE_CONTENT_LOADED,
                updatePointCloudSize,
            );
            var geodesic  = view.controls.getCameraCoordinate();
            var deltaPointCloud = geodesic.geodesicNormal.clone().multiplyScalar(-46);

            contextXR.pointLayer.object3d.position.add(deltaPointCloud);
            contextXR.interactiveLayers.push(contextXR.pointLayer.object3d);

            // view.addLayer(contextXR.pointLayer); doesn't work. Those little thing that takes time to figure out
            itowns.View.prototype.addLayer.call(view, contextXR.pointLayer);

            // add building layer

            var buildingsSource = new itowns.VectorTilesSource({
            style: 'https://wxs.ign.fr/essentiels/static/vectorTiles/styles/PLAN.IGN/standard.json',
            // Filter to get only buildings
            filter: (layer) => {
                return layer['source-layer'].includes('bati_surf')
                    && layer.paint["fill-color"];
            },
        });

        var buildingsLayer = new itowns.FeatureGeometryLayer('building-layer-ign', {
            source: buildingsSource,
            zoom: {min: 15},
            // increases reprojection from 3857 to 4326 reprojection speed with little inaccuracy introduced.
            // More details on http://www.itowns-project.org/itowns/docs/#api/Layer/FeatureGeometryLayer
            accurate: false,
            style: new itowns.Style({
                fill: {
                    base_altitude: (p) => p.alti_sol || 0,
                    extrusion_height: (p) => p.hauteur || 0
                },
            })
        });

        view.addLayer(buildingsLayer);


            function updatePointCloudSize({tileContent}) {
                tileContent.traverse(function (obj) {
                    if (obj.isPoints) {
                        obj.material.size = 200.0;
                    }
                });
            }
        

            // ------------- webxr interaction ----------------
            view.scene.matrixWorldAutoUpdate = true;
            
            initXR();

            function addXRObjects() {
                contextXR.raycaster = new itowns.THREE.Raycaster();

                var cameraTargetPosition = view.controls.getCameraCoordinate().clone();
                var meshCoord =  new itowns.Coordinates(cameraTargetPosition.crs, cameraTargetPosition.x, cameraTargetPosition.y, cameraTargetPosition.z );
                meshCoord.altitude -= 10050;

                contextXR.raycaster.ray.origin.copy(meshCoord.as(view.referenceCrs));
                contextXR.floor = new itowns.THREE.Mesh(
					new itowns.THREE.PlaneGeometry( 10000, 10000, 1, 1 ),
					new itowns.THREE.MeshBasicMaterial( { color: 0x222222, side: itowns.THREE.DoubleSide } )
				);
                contextXR.floor.name = "floor";
                // position and orientation of the mesh
                contextXR.floor.position.copy(meshCoord.as(view.referenceCrs));
                contextXR.floor.lookAt(new itowns.THREE.Vector3(0, 0, 0));

                // update coordinate of the mesh
                contextXR.floor.updateMatrixWorld();
                // add the mesh to the scene
                view.scene.add(contextXR.floor);

                meshCoord.altitude += 1;
                contextXR.marker = new itowns.THREE.Mesh(
					new itowns.THREE.CircleGeometry( 50, 32 ),
					new itowns.THREE.MeshBasicMaterial( { color: 0xbcbcbc, side: itowns.THREE.DoubleSide } )
				);
                contextXR.marker.position.copy(meshCoord.as(view.referenceCrs));
                contextXR.marker.lookAt(new itowns.THREE.Vector3(0, 0, 0));
                contextXR.marker.name = "marker";
                contextXR.marker.updateMatrixWorld();
				view.scene.add(contextXR.marker);

                view.notifyChange();
            }

            function loadBuildingGltf() {
                                // Load a glTF resource
                                itowns.glTFLoader.load(
                // resource URL, do not commit as is.
                "myGLB.glb",

                
                // called when the resource is loaded
                (gltf) => {
                    gltf.scene.position.copy(new itowns.THREE.Vector3(4486191.121470811, 477820.22721133975, 4495989.354518597));
                    
                    gltf.scene.lookAt(new itowns.THREE.Vector3(0, 0, 0));
                    gltf.scene.rotateX(Math.PI / 2);
                    gltf.scene.rotateX(Math.PI);

                    // update coordinate of the mesh
                    gltf.scene.updateMatrixWorld();
                    const gltfBbox = new itowns.THREE.Box3();
                    gltfBbox.setFromObject(gltf.scene);
                    
                    view.scene.add(gltf.scene);
                    const helper = new itowns.THREE.Box3Helper( gltfBbox, 0xffff00 );
                    helper.name="bboxGltfHelper";
                    helper.visible = false;
                    view.scene.add(helper);
                    var gltfBox = XRUtils.generateVRBox(gltf.scene);
                    applyGltfBoxToCHilds(gltf.scene, gltfBox);
                    contextXR.interactiveLayers.push(gltf.scene);
                    gltf.VRBbox = helper;
                    view.notifyChange();
                },
                // called while loading is progressing
                () => {},
                // called when loading has errors
                (error) => {
                    // eslint-disable-next-line no-console
                    console.log("An error happened :");
                    // eslint-disable-next-line no-console
                    console.log(error);
                });

                function applyGltfBoxToCHilds(gltfScene, gltfBox) {
                    gltfScene.traverse(o => {
                        o.VRBbox = gltfBox;
                    });
                }
            }
                

            function initXR() {
                contextXR.renderer = view.mainLoop.gfxEngine.renderer;
                Controllers.addControllers(view, contextXR);

                addXRObjects();
                
                 contextXR.renderer.xr.addEventListener( 'sessionstart', function ()
                 {

                    document.addEventListener('keydown', function listenDebug(evt) {
                        console.log(evt, 'pressed');
                    });
                    contextXR.baseReferenceSpace = contextXR.renderer.xr.getReferenceSpace();
                    view.scene.children.forEach((child) => {if(child.name === 'xrHeadset') { contextXR.xrHeadSet = child;} });
                    
                    var testPicking = XRUtils.showPosition('testPicking', new itowns.THREE.Vector3(4486512.584368641, 476258.50340769894, 4497781.931009745), 0xf9429e, 25, true);
                    // contextXR.interactiveLayers.push(testPicking);
                    var testPickingBbox = XRUtils.showPosition('testPickingConcrete', new itowns.THREE.Vector3(4486480, 476250, 4497781.931009745), 0x000000, 25, true);
                    XRUtils.generateVRBox(testPickingBbox);
                    // contextXR.interactiveLayers.push(testPickingBbox);
                    contextXR.interactiveLayers = contextXR.interactiveLayers.concat(view.tileLayer.level0Nodes); 

                   // const orbitControls = new itowns.THREE.OrbitControls( view.controls.camera, contextXR.renderer.domElement );
                   // orbitControls.target = gltf.centor vector
                 });
            }
        
            /**
             *  try to performs terrain intersection by pixel reading from a camera set onto controller coordinates.
             *  FIXME Needs fixes for terrain intersection. 
             *  Distances got in return doesn't allow to know if we reached the far distance without intersecting nothing
             *  Distances got from an intersection is wrong.
             */
            function intersectInteractiveLayers() {
                if(!contextXR.controller2 || !contextXR.cameraRightGrp.camera) {
                    return [];
                }
                contextXR.controller2.updateMatrixWorld();
                // test intersection coordinate with terrain
                contextXR.tempMatrix.identity().extractRotation(contextXR.controller2.matrixWorld);
                contextXR.raycaster.ray.origin.setFromMatrixPosition(contextXR.controller2.matrixWorld);
                contextXR.raycaster.ray.direction.set(0, 0, -1).applyMatrix4( contextXR.tempMatrix);

                return contextXR.raycaster.intersectObjects(contextXR.interactiveLayers);

               // FIXME, doesn't work + really perf consuming
               // tryCameraIntersection();
            }

            function tryCameraIntersection() {
                contextXR.cameraRightGrp.camera.position.copy(contextXR.raycaster.ray.origin);
                contextXR.cameraRightGrp.camera.lookAt(contextXR.cameraRightGrp.camera.position.clone().add(contextXR.raycaster.ray.direction));
                contextXR.cameraRightGrp.camera.updateProjectionMatrix();
                contextXR.cameraRightGrp.cameraHelper.update();
                // pick terrain coordinate from controller camera 
                var pickedValueRightCamera = new itowns.THREE.Vector3();
                // view.getPickingPositionFromDepth(null, pickedValueRightCamera, contextXR.cameraRightGrp.camera);
                view.getPickingPositionFromDepth(null, pickedValueRightCamera);
                // var testPicking = view.pickObjectsAt(0,0); // TODO change camera

                if(pickedValueRightCamera) {
                    // console.log('result');
                }else{
                    // console.log('no result');
                }
/**
                if(testPicking.length > 0) {
                    // XRUtils.updateBboxVisibility(testPicking[0].object); doesn't give the expected bbox
                    view.getPickingPositionFromDepth(null, pickedValueRightCamera, contextXR.cameraRightGrp.camera);
                   // XRUtils.showPosition('accuratePsositon', pickedValueRightCamera, 0xb518c7, 30, true);
                  //  XRUtils.addPositionPoints('terrainPickAccurate', pickedValueRightCamera, 0xb51800,30, true);
                }
                */
                
               // var pickedValueRightCamera = itowns.CameraUtils.getTransformCameraLookingAtTarget(view, contextXR.cameraRightGrp.camera).coord;

                // XRUtils.addPositionPoints('terrainPickAccurate', pickedValueRightCamera, 0xb518c7,30, true);
                // console.log(pickedValue, pickedValueRightCamera);
                

               var coordOnterrain = new itowns.Coordinates(view.controls.getCameraCoordinate().crs, pickedValueRightCamera.x,pickedValueRightCamera.y,pickedValueRightCamera.z);
               // XRUtils.showPositionVerticalLine('better_terrain_intersectt', pickedValueRightCamera, 0xb518c7, 1000, true);


                var pointer = new itowns.THREE.Vector2(0,0);
                // try to pick from hand camera
                contextXR.raycaster.setFromCamera(pointer, contextXR.cameraRightGrp.camera);
                // intersect ok for gltf and 3dtiles, not for terrain elevation as we don't have a geometry of the elevation.
                var test = contextXR.raycaster.intersectObjects(contextXR.interactiveLayers);
                return test;
            }

            function render() {
                return;
                if(!contextXR.controller2.userData.isSelecting) {
                    // if not selecting reset previous state
                    contextXR.INTERSECTION = undefined;
                }
                if (!contextXR.controller2.userData.lockedTeleportPosition) {
                    contextXR.INTERSECTION = undefined;
                    const intersects = intersectInteractiveLayers(); 
                    if (intersects && intersects.length > 0 ) {
                        XRUtils.updateBboxVisibility(intersects[0].object);
                        updateIntersectionMarker(intersects[0]);
                        if (contextXR.controller2.userData.isSelecting === true) {
                            contextXR.INTERSECTION = intersects[ 0 ].point;
                            if(view.meshPointer) {
                                view.meshPointer.visible = false;
                            }
                        }
                    } else if (contextXR.visibleBbox) {
                        contextXR.visibleBbox.visible = false;
                        contextXR.visibleBbox = undefined;
                    }
                }

                if ( contextXR.INTERSECTION )
                {
                    var intersectionCoord = new itowns.Coordinates(view.referenceCrs, contextXR.INTERSECTION.x, contextXR.INTERSECTION.y, contextXR.INTERSECTION.z);
                    var justElevationAt = itowns.DEMUtils.getElevationValueAt(view.tileLayer,  view.controls.getCameraCoordinate().clone(), itowns.DEMUtils.PRECISE_READ_Z);
                    getJumpCoordinate(intersectionCoord);

                    var cameraFloorIntersect = view.controls.getCameraCoordinate().clone();
                    // FIXME result is not stricly the camera position as expected, maybe due to the intersection position?
                    // FIXME getCameraCoordinate doesn't update on webxr camera move, maybe test it in "unbounded" / "bounded" context
                    var cameraTargetPosition = view.controls.getCameraCoordinate().clone();
                    /* the staircase effect find explanation in regard of view.camera.camera3D.position z evolution
                    for some reason, position is highly rounded when not to initial vr pos.
                    but camera matrices seems like in the same level of definition...
                    */
                    cameraFloorIntersect.altitude = justElevationAt;
                    XRUtils.showPosition('findMeCamera', cameraFloorIntersect.as(view.referenceCrs), 0x44aaff, 100, true);

                    // showing camera floor intersection
                    contextXR.marker.position.copy(cameraFloorIntersect.as(view.referenceCrs));
                } else {
                    // if no more intersection, reset coords.
                    XRUtils.removeReference('positionJumpDebug')
                    XRUtils.removeReference('positionJump');
                    XRUtils.removeReference('findMeCamera');
                    XRUtils.removeReference('verticalAxisJump');
                    contextXR.coordOnCamera = undefined;
                }
                contextXR.marker.visible = contextXR.INTERSECTION !== undefined;
            }

            function updateIntersectionMarker(intersectionObject){
                var intersectionVector = intersectionObject.point;
                if(intersectionObject.object.type === 'Points') {
                    if(view.meshPointer){
                        view.meshPointer.visible = false;
                    }
                    
                    XRUtils.showPosition('pointsIntersections', intersectionVector, 0xfeff00, view.camera.camera3D.position.distanceTo(intersectionVector) / 100, false);
                }
                else {
                    XRUtils.removeReference('pointsIntersections');
                    // update marker on terrain position
                    var intersectPosition = new itowns.Coordinates(view.referenceCrs);
                    intersectPosition.setFromVector3(intersectionVector);
                    var coordIntersectedMappedOnLayer = itowns.DEMUtils.getTerrainObjectAt(view.tileLayer, intersectPosition, itowns.DEMUtils.PRECISE_READ_Z);
                    if(view.meshPointer && coordIntersectedMappedOnLayer) {
                        view.meshPointer.visible = true;
                        view.meshPointer.position.copy(coordIntersectedMappedOnLayer.coord.as(view.referenceCrs));
                    }
                }
                
            }

            function getJumpCoordinate(intersectionCoord) {
                // not a {itowns.Coordinates} 
                var coordOnCamera = itowns.DEMUtils.getTerrainObjectAt(view.tileLayer, intersectionCoord, itowns.DEMUtils.PRECISE_READ_Z);
                var coordIntersectItowns = coordOnCamera.coord.clone().as('EPSG:4326');
                // update jump target altitude.
                if (contextXR.coordOnCamera && contextXR.deltaAltitude) {
                    if(coordOnCamera.coord.altitude + contextXR.deltaAltitude < coordOnCamera.coord.altitude + Controllers.MIN_DELTA_ALTITUDE) {
                        contextXR.deltaAltitude = Controllers.MIN_DELTA_ALTITUDE;
                    }
                    coordOnCamera.coord.altitude += contextXR.deltaAltitude;
                } else {
                     // by default set altitude to the current camera elevation from terrain
                     let cameraCoordOnTerrain = itowns.DEMUtils.getTerrainObjectAt(view.tileLayer, view.controls.getCameraCoordinate().clone(), itowns.DEMUtils.PRECISE_READ_Z);
                     coordOnCamera.coord.altitude += cameraCoordOnTerrain.coord.z;
                     contextXR.deltaAltitude = cameraCoordOnTerrain.coord.z;
                }
                
                // must clone Coordinate to avoid side effect, maybe with DEMUtils, but not sure.
                contextXR.coordOnCamera = new itowns.Coordinates(coordOnCamera.coord.crs);
                contextXR.coordOnCamera.setFromVector3(coordOnCamera.coord);
                XRUtils.showPosition('positionJump',  contextXR.coordOnCamera.as(view.referenceCrs), 0xfe0c00, 30, false);
                XRUtils.showPositionVerticalLine('verticalAxisJump', intersectionCoord, 0xfe0c00, 10000, false);
                XRUtils.showPosition('positionJumpDebug', intersectionCoord, 0xfeff00, 5500, true);
            }

            //---------  add fake to ground

            function addMeshToScene() {
                // creation of the new mesh (a cylinder)
                var THREE = itowns.THREE;
                var geometry = new THREE.CylinderGeometry(0, 10, 60, 8);
                var material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                var meshPointer = new THREE.Mesh(geometry, material);

                // get the position on the globe, from the camera
                var cameraTargetPosition = view.controls.getLookAtCoordinate();

                // position of the mesh
                var meshCoord = cameraTargetPosition.clone();
                meshCoord.altitude += 30;

                // position and orientation of the mesh
                meshPointer.position.copy(meshCoord.as(view.referenceCrs));
                meshPointer.lookAt(new THREE.Vector3(0, 0, 0));
                meshPointer.rotateX(Math.PI / 2);

                // update coordinate of the mesh
                meshPointer.updateMatrixWorld();

                // add the mesh to the scene
                view.scene.add(meshPointer);

                // make the object usable from outside of the function
                view.meshPointer = meshPointer;
                view.notifyChange();
            }

            // Listen for globe full initialisation event

            view.addEventListener(itowns.GLOBE_VIEW_EVENTS.GLOBE_INITIALIZED, function globeInitialized() {
                // eslint-disable-next-line no-console
                console.info('Globe initialized');


               addMeshToScene();
            });

            
            

            // Add the UI Debug
            var d = new debug.Debug(view, menuGlobe.gui);
            debug.createTileDebugUI(menuGlobe.gui, view, view.tileLayer, d);
            debug.create3dTilesDebugUI(menuGlobe.gui, view, contextXR.pointLayer, d);

            d.switch = function() {
                Controllers.change3DTileRepresentation();
            }
            menuGlobe.gui.add(d, 'switch').name('Mode Switch');

            // ---------- DISPLAY A DIGITAL ELEVATION MODEL : ----------

            // Add two elevation layers, each with a different level of detail. Here again, each layer's properties are
            // defined in a json file.
            function addElevationLayerFromConfig(config) {
                config.source = new itowns.WMTSSource(config.source);
                var elevationLayer = new itowns.ElevationLayer(config.id, config);
                view.addLayer(elevationLayer).then(menuGlobe.addLayerGUI.bind(menuGlobe));
            }
            itowns.Fetcher.json('./layers/JSONLayers/IGN_MNT_HIGHRES.json').then(addElevationLayerFromConfig);
            // must keep it, Failed to execute 'updateRenderState' on 'XRSession': Failed to read the 'depthFar' property from 'XRRenderStateInit': The provided double value is non-finite.
            itowns.Fetcher.json('./layers/JSONLayers/WORLD_DTM.json').then(addElevationLayerFromConfig);
        </script>
    </body>
</html>
