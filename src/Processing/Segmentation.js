/**
 * Generated On: 2015-10-5
 * Class: Segmentation
 * Description: Work on segmentation on images.
 */


/*eslint-disable */
import THREE from 'THREE';
import Sobel from 'Sobel';

var jsonFile = require('Processing/vj_classifier_40_20.json'); 
var json = [40,20,-1.457260012626648,16,0,2,5,3,31,16,-1,5,7,31,8,2,0.1566464006900787,-0.4576956033706665,0.7241135239601135,0,2,0,0,1,14,-1,0,7,1,7,2,0.0024098840076476336,0.2517040073871613,-0.6694514155387878,0,2,4,1,26,18,-1,4,7,26,6,3,0.9040935039520264,-0.0220578592270613,2111.156005859375,0,2,13,13,17,6,-1,13,15,17,2,3,-0.0240260194987059,0.5569531917572021,-0.2630704045295715,0,2,0,0,39,2,-1,13,0,13,2,3,0.0110279303044081,0.186523899435997,-0.6365718841552734,0,2,11,0,19,6,-1,11,3,19,3,2,-0.0397755205631256,0.5743033289909363,-0.2006036937236786,0,2,32,6,8,10,-1,36,6,4,10,2,-0.0342506505548954,0.6323683261871338,-0.1898240000009537,0,2,12,0,12,2,-1,16,0,4,2,3,-0.004874124191701412,-0.7127041816711426,0.1371698975563049,0,2,15,0,6,1,-1,17,0,2,1,3,0.0007601780234836042,0.1123183965682983,-0.6903954744338989,0,2,0,8,8,6,-1,2,8,4,6,2,-0.007363832090049982,0.4599204063415527,-0.2040746957063675,0,2,39,0,1,20,-1,39,10,1,10,2,0.007941970601677895,0.1210137009620667,-0.6272733211517334,0,2,38,4,2,16,-1,38,12,2,8,2,-0.0137741696089506,-0.6415361166000366,0.1261398047208786,0,2,4,0,33,6,-1,4,2,33,2,3,-0.0346347987651825,0.4522475898265839,-0.2037056982517242,0,2,25,7,15,5,-1,30,7,5,5,3,-0.0227046199142933,0.5153126120567322,-0.1439929008483887,0,2,21,18,12,2,-1,27,18,6,2,2,-0.005280990153551102,-0.6474921703338623,0.1426389068365097,0,2,35,19,3,1,-1,36,19,1,1,3,-0.0001802434999262914,-0.6054778099060059,0.1167600005865097,-1.4394240379333496,17,0,2,6,0,30,20,-1,6,5,30,10,2,0.2739472985267639,-0.3872255980968475,0.7199068069458008,0,2,13,12,15,8,-1,13,14,15,4,2,-0.032458309084177,0.531822681427002,-0.22849540412426,0,2,0,10,2,10,-1,0,15,2,5,2,-0.004696010146290064,-0.6554322838783264,0.1986259073019028,0,2,8,0,19,6,-1,8,3,19,3,2,-0.0505278892815113,0.4624488949775696,-0.2599166035652161,0,2,28,0,6,2,-1,31,0,3,2,2,-0.001337161986157298,-0.6495875716209412,0.2585332989692688,0,2,18,0,6,2,-1,21,0,3,2,2,-0.0020562210120260715,-0.7221515774726868,0.0984905436635017,1,2,1,14,2,1,-1,1,14,1,1,2,-0.0004918079939670861,-0.6029412150382996,0.1371348947286606,0,2,39,0,1,20,-1,39,5,1,10,2,0.004372633993625641,0.1473681032657623,-0.6026269793510437,0,2,8,10,29,9,-1,8,13,29,3,3,0.0796617716550827,-0.2470013946294785,0.507641077041626,0,2,14,0,9,1,-1,17,0,3,1,3,-0.0010174569906666875,-0.5101287961006165,0.2038806974887848,0,2,0,9,9,4,-1,3,9,3,4,3,-0.0100585296750069,0.3903067111968994,-0.2192725986242294,0,2,35,19,3,1,-1,36,19,1,1,3,0.00027858460089191794,0.1386964023113251,-0.6145154237747192,0,2,1,8,8,5,-1,3,8,4,5,2,0.008656186982989311,-0.1572833955287933,0.5205265879631042,0,2,6,12,24,6,-1,6,14,24,2,3,-0.045016560703516,0.4832820892333984,-0.147636204957962,0,2,1,7,12,8,-1,4,7,6,8,2,-0.0299689806997776,0.5705937147140503,-0.0873897224664688,0,2,20,2,14,6,-1,20,5,14,3,2,0.0296675991266966,-0.1365237981081009,0.4112618863582611,0,2,19,18,14,2,-1,19,19,14,1,2,0.0006288057193160057,-0.2682631015777588,0.2288966029882431,-1.5770150423049927,23,0,2,6,0,29,20,-1,6,5,29,10,2,0.3484270870685577,-0.2968283891677856,0.6596150994300842,0,2,0,0,1,20,-1,0,5,1,10,2,0.0030129130464047194,0.2015344947576523,-0.6807634830474854,0,2,0,4,30,15,-1,0,9,30,5,3,0.0729842334985733,-0.2963831126689911,0.3525682091712952,0,2,6,4,24,16,-1,6,8,24,8,2,0.5522456169128418,-0.0335382483899593,1752.18798828125,0,2,39,0,1,18,-1,39,9,1,9,2,0.0047045000828802586,0.1548871994018555,-0.6546499729156494,0,2,39,4,1,16,-1,39,12,1,8,2,-0.0051068528555333614,-0.6063073873519897,0.1148030981421471,0,2,0,6,9,8,-1,3,6,3,8,3,-0.0183473508805037,0.4295391142368317,-0.1930388957262039,0,2,1,0,36,8,-1,13,0,12,8,3,-0.0166394505649805,0.2240505069494247,-0.3554258942604065,0,2,8,0,12,2,-1,12,0,4,2,3,-0.00468160817399621,-0.6481267809867859,0.1209279000759125,0,2,16,18,1,2,-1,16,19,1,1,2,0.000008512798558513168,-0.3172647058963776,0.2206549048423767,0,2,6,0,15,2,-1,11,0,5,2,3,0.003216502955183387,0.1703822016716003,-0.5388550162315369,0,2,1,7,6,9,-1,4,7,3,9,2,0.0275194607675076,-0.1345458030700684,0.5846796035766602,0,2,7,0,25,4,-1,7,2,25,2,2,-0.009821119718253613,0.323370099067688,-0.2810510098934174,0,2,0,6,15,7,-1,5,6,5,7,3,-0.0324554406106472,0.4571667015552521,-0.1507568955421448,0,2,22,18,3,2,-1,23,18,1,2,3,-0.0004878194013144821,-0.669386088848114,0.1224476024508476,0,2,22,18,3,2,-1,23,18,1,2,3,0.0005203629261814058,0.1087083965539932,-0.7099509239196777,0,2,13,14,19,3,-1,13,15,19,1,3,-0.0094559695571661,0.4840480089187622,-0.1731577962636948,0,2,8,14,26,3,-1,8,15,26,1,3,0.006460652220994234,-0.1381213068962097,0.4630866944789887,0,2,0,4,1,14,-1,0,11,1,7,2,0.00568966381251812,0.1101185008883476,-0.5641040205955505,0,2,1,0,3,1,-1,2,0,1,1,3,-0.00035676080733537674,-0.6788802146911621,0.0743042305111885,0,2,1,0,3,2,-1,2,0,1,2,3,0.0006101286271587014,0.0783167108893394,-0.6433150768280029,0,2,31,10,9,3,-1,34,10,3,3,3,-0.0055418461561203,0.3993150889873505,-0.15677909553051,0,2,31,7,8,7,-1,33,7,4,7,2,0.00939587689936161,-0.1542233973741531,0.4876402914524078,-1.4135329723358154,23,0,2,18,12,18,6,-1,18,15,18,3,2,-0.0333617590367794,0.4484702944755554,-0.3955127894878388,0,2,0,6,10,9,-1,5,6,5,9,2,0.0429909713566303,-0.1922983974218369,0.5417929291725159,0,2,9,2,18,6,-1,9,4,18,2,3,-0.0289117693901062,0.4734914898872376,-0.1883545964956284,0,2,16,16,12,2,-1,16,17,12,1,2,0.0026466399431228638,-0.2028187960386276,0.4074051976203919,0,2,4,2,31,4,-1,4,4,31,2,2,0.0457421503961086,-0.1713007986545563,0.5628321170806885,0,2,0,5,15,10,-1,5,5,5,10,3,-0.0308973398059607,0.4402922987937927,-0.1806174069643021,0,2,0,6,2,14,-1,0,13,2,7,2,-0.0114586595445871,-0.6380584836006165,0.1595150977373123,0,2,4,19,24,1,-1,12,19,8,1,3,0.006190984044224024,0.1240217983722687,-0.6031079888343811,0,2,39,0,1,18,-1,39,6,1,6,3,0.00587996281683445,0.0994692519307137,-0.6296361088752747,0,2,30,7,8,7,-1,32,7,4,7,2,-0.0110656600445509,0.5324050188064575,-0.1341421008110046,0,2,29,7,9,10,-1,32,7,3,10,3,0.0208820197731256,-0.182911604642868,0.4700776040554047,0,2,30,4,10,8,-1,35,4,5,8,2,0.0258310604840517,-0.1454057991504669,0.4810526072978973,0,2,2,0,8,2,-1,6,0,4,2,2,0.0012362709967419505,0.1611443012952805,-0.5103085041046143,0,2,33,19,6,1,-1,35,19,2,1,3,-0.0007737302221357822,-0.6048833727836609,0.1084856018424034,0,2,13,18,1,2,-1,13,19,1,1,2,0.000008315008017234504,-0.2550525963306427,0.2378111034631729,0,2,39,4,1,12,-1,39,8,1,4,3,-0.005756974220275879,-0.6385244131088257,0.0832127630710602,0,2,17,14,13,4,-1,17,15,13,2,2,0.007906986400485039,-0.1130883023142815,0.5479819178581238,0,2,37,19,3,1,-1,38,19,1,1,3,-0.00017583920271135867,-0.5178835988044739,0.1115081012248993,0,2,8,14,20,3,-1,8,15,20,1,3,-0.0075908019207417965,0.363310694694519,-0.160823404788971,0,2,38,19,2,1,-1,39,19,1,1,2,-0.000158776601892896,-0.5431122183799744,0.1142852008342743,0,2,5,7,9,9,-1,8,7,3,9,3,0.0204955991357565,-0.1435496062040329,0.437796413898468,0,2,13,0,15,4,-1,13,2,15,2,2,-0.006497757975012064,0.2751171886920929,-0.2259199023246765,0,2,9,0,8,1,-1,13,0,4,1,2,0.0012415030505508184,0.0931680426001549,-0.5981522798538208,-1.4433300495147705,29,0,2,3,1,34,18,-1,3,7,34,6,3,0.2513116002082825,-0.3916828036308289,0.4714235961437225,0,2,39,2,1,18,-1,39,8,1,6,3,0.003819210920482874,0.1548590958118439,-0.5544769763946533,0,2,21,9,19,8,-1,21,11,19,4,2,0.0102149099111557,-0.2926228046417236,0.3166767954826355,0,2,7,1,16,18,-1,7,7,16,6,3,0.6996343731880188,-0.0222673993557692,2325.625,0,2,0,0,2,10,-1,0,5,2,5,2,0.0014605389442294836,0.1398248970508575,-0.4677129983901978,0,2,24,18,1,2,-1,24,19,1,1,2,0.00000942768656386761,-0.2724730968475342,0.2237053066492081,0,2,1,18,3,2,-1,2,18,1,2,3,-0.0003283859114162624,-0.5535985827445984,0.105119101703167,0,2,0,6,8,9,-1,2,6,4,9,2,-0.0151326302438974,0.4093672037124634,-0.1673945039510727,0,2,1,18,3,2,-1,2,18,1,2,3,0.0004734931862913072,0.1102029010653496,-0.6141216158866882,0,2,3,4,6,10,-1,6,4,3,10,2,-0.00835520401597023,0.3739759027957916,-0.1892687976360321,0,2,5,0,21,2,-1,12,0,7,2,3,-0.0105713903903961,-0.5340564250946045,0.1359584033489227,0,2,9,1,22,6,-1,9,3,22,2,3,-0.0408633090555668,0.3704353868961334,-0.1683551073074341,0,2,11,2,23,4,-1,11,3,23,2,2,0.0064246379770338535,-0.1394927948713303,0.4836843013763428,0,2,11,0,12,1,-1,15,0,4,1,3,0.0018911199877038598,0.1177038997411728,-0.6050102114677429,0,2,0,12,1,8,-1,0,16,1,4,2,-0.0022926758974790573,-0.5941177010536194,0.0615938417613506,0,2,15,0,1,20,-1,15,5,1,10,2,0.0205018408596516,-0.0973781570792198,0.6134604215621948,0,2,10,8,15,4,-1,15,8,5,4,3,-0.0126830404624343,0.3756402134895325,-0.1642259955406189,0,2,17,8,12,5,-1,21,8,4,5,3,-0.0134289097040892,0.3931738138198853,-0.1347610950469971,0,2,22,6,12,10,-1,26,6,4,10,3,-0.0237477105110884,0.3702862858772278,-0.1505322009325028,0,2,27,4,12,8,-1,31,4,4,8,3,-0.0175805296748877,0.3771466016769409,-0.1518321037292481,0,2,36,18,3,2,-1,37,18,1,2,3,-0.0004621752887032926,-0.6187177896499634,0.099529080092907,0,2,36,18,3,2,-1,37,18,1,2,3,0.0003193560987710953,0.0869649797677994,-0.5312157869338989,0,2,17,2,14,2,-1,17,3,14,1,2,-0.003383004106581211,0.3062868118286133,-0.1776036024093628,0,2,22,1,14,6,-1,22,4,14,3,2,0.0293047595769167,-0.1454907059669495,0.4146578907966614,0,2,7,0,12,2,-1,10,0,6,2,2,0.0032128191087394953,0.0797053202986717,-0.6211380958557129,0,2,25,15,2,4,-1,25,17,2,2,2,0.001279096002690494,-0.1761956959962845,0.2867588102817535,0,2,9,15,27,4,-1,9,17,27,2,2,-0.03411003947258,0.423979789018631,-0.1190870031714439,0,2,10,13,9,6,-1,10,15,9,2,3,-0.024503830820322,0.4148963987827301,-0.1243652999401093,0,2,39,7,1,9,-1,39,10,1,3,3,-0.0033489849884063005,-0.6251851916313171,0.0805651769042015,-1.5463800430297852,37,0,2,5,0,31,20,-1,5,5,31,10,2,0.4413439035415649,-0.2173812985420227,0.6138597726821899,0,2,4,2,26,10,-1,4,7,26,5,2,0.4328199028968811,0.019754009321332,1253.56298828125,0,2,39,10,1,10,-1,39,15,1,5,2,-0.0032347040250897408,-0.6187285780906677,0.1266569048166275,0,2,25,12,15,6,-1,25,15,15,3,2,-0.0180884394794703,0.3627839982509613,-0.2450758963823319,0,2,20,13,14,4,-1,20,15,14,2,2,0.1131779029965401,-0.0543531104922295,-788.0625,0,2,0,2,1,18,-1,0,8,1,6,3,0.003812819952145219,0.1226364970207214,-0.6196715831756592,0,2,18,0,22,5,-1,29,0,11,5,2,-0.002349630929529667,-0.4027984142303467,0.153847798705101,0,2,0,5,4,9,-1,2,5,2,9,2,-0.0027252929285168648,0.2771830856800079,-0.2406982034444809,0,2,1,2,15,18,-1,1,8,15,6,3,0.0630339235067368,-0.1891085952520371,0.3232224881649017,1,2,16,0,2,4,-1,16,0,1,4,2,0.0007922400836832821,-0.2813838124275208,0.2299136966466904,1,2,1,15,4,1,-1,1,15,2,1,2,0.001302705961279571,0.1769621968269348,-0.4539987146854401,0,2,10,18,15,2,-1,15,18,5,2,3,-0.007895837537944317,-0.595310389995575,0.0835147723555565,0,2,12,19,12,1,-1,16,19,4,1,3,0.0015465939650312066,0.1017991006374359,-0.5190001130104065,1,2,7,8,6,6,-1,5,10,6,2,3,0.0330469496548176,-0.1089240983128548,0.6511077880859375,0,2,0,14,12,1,-1,6,14,6,1,2,-0.004209623206406832,0.4462670981884003,-0.1038523986935616,0,2,26,0,3,2,-1,27,0,1,2,3,0.0005478120874613523,0.0817832425236702,-0.6492171883583069,0,2,0,10,8,4,-1,2,10,4,4,2,-0.006885445211082697,0.3521888852119446,-0.151188001036644,0,2,0,7,5,6,-1,0,9,5,2,3,-0.00837847962975502,-0.6295825242996216,0.0778024420142174,1,2,34,1,6,2,-1,34,1,6,1,2,-0.008859130553901196,0.6468225717544556,-0.0828215777873993,0,2,30,7,9,6,-1,33,7,3,6,3,-0.0122549599036574,0.3922100067138672,-0.1405584961175919,0,3,34,1,4,12,-1,34,1,2,6,2,36,7,2,6,2,-0.006229147780686617,0.4008535146713257,-0.1207474991679192,0,2,8,15,28,4,-1,15,15,14,4,2,-0.008479135110974312,0.2244711965322495,-0.2321169972419739,0,2,38,0,2,4,-1,39,0,1,4,2,-0.0005379773210734129,-0.5453556180000305,0.0887360498309135,0,2,0,9,2,4,-1,0,11,2,2,2,-0.0018000260461121798,-0.5363063812255859,0.080138623714447,0,2,24,6,15,10,-1,29,6,5,10,3,-0.0384686216711998,0.3687056005001068,-0.1348233073949814,0,2,11,12,19,4,-1,11,13,19,2,2,-0.008788341656327248,0.4258005023002625,-0.1025599986314774,0,2,10,13,15,3,-1,10,14,15,1,3,0.007662512827664614,-0.1145220026373863,0.4651086032390595,0,2,37,18,3,2,-1,38,18,1,2,3,0.0006280695088207722,0.0688945576548576,-0.7096288800239563,0,2,10,13,19,4,-1,10,14,19,2,2,-0.0143916197121143,0.3605318069458008,-0.1242697015404701,0,2,39,3,1,16,-1,39,11,1,8,2,-0.010065839625895,-0.6479626297950745,0.0665781497955322,0,2,26,0,3,1,-1,27,0,1,1,3,-0.00016822510224301368,-0.4638552963733673,0.0863223895430565,0,2,37,0,2,20,-1,37,10,2,10,2,0.0160769000649452,0.0777836069464684,-0.5562906265258789,0,2,8,12,12,6,-1,8,14,12,2,3,0.009848489426076412,-0.1457924991846085,0.2849338054656982,0,2,0,17,2,3,-1,1,17,1,3,2,0.0002753087901510298,0.100201703608036,-0.4086363911628723,0,2,18,17,14,2,-1,18,18,14,1,2,0.0020339300390332937,-0.17515729367733,0.2474025040864945,0,2,4,2,17,6,-1,4,5,17,3,2,0.0284066796302795,-0.1429104954004288,0.2846223115921021,0,2,1,4,10,5,-1,6,4,5,5,2,-0.007383008021861315,0.3019321858882904,-0.1673574000597,-1.5490130186080933,42,0,2,3,0,33,20,-1,3,5,33,10,2,0.3396601974964142,-0.2707732021808624,0.425066202878952,0,2,0,0,2,20,-1,0,5,2,10,2,0.0026093439664691687,0.1629298031330109,-0.5271294116973877,0,2,39,8,1,8,-1,39,10,1,4,2,0.0012657289626076818,0.1445924043655396,-0.5364093780517578,0,2,12,10,18,6,-1,12,12,18,2,3,0.0234267599880695,-0.2409446984529495,0.2742854058742523,0,2,32,5,8,12,-1,36,5,4,12,2,-0.0583961196243763,0.5286884903907776,-0.0975080877542496,0,2,22,0,7,6,-1,22,3,7,3,2,-0.008428830653429031,0.3114627003669739,-0.266202986240387,0,2,15,0,16,2,-1,19,0,8,2,2,0.00399909820407629,0.1320455968379974,-0.5946980118751526,0,2,15,0,15,2,-1,20,0,5,2,3,-0.006030815187841654,-0.5876402854919434,0.0799152478575706,1,2,31,0,7,4,-1,30,1,7,2,2,-0.0077101849019527435,0.4271157085895538,-0.1397614926099777,0,2,1,8,8,3,-1,3,8,4,3,2,-0.004753476940095425,0.3243243098258972,-0.1555559933185577,0,2,2,6,4,10,-1,4,6,2,10,2,0.0200456492602825,-0.0612733401358128,0.605829119682312,0,2,1,19,8,1,-1,5,19,4,1,2,0.0005795505130663514,0.1115541979670525,-0.4296573996543884,0,2,18,16,1,4,-1,18,18,1,2,2,0.0004428969114087522,-0.2248658984899521,0.2508299052715302,0,2,36,0,4,1,-1,37,0,2,1,2,-0.00031322010909207165,-0.5564563274383545,0.0967475771903992,1,2,32,1,7,4,-1,31,2,7,2,2,0.008486654609441757,-0.1110858023166657,0.5012266039848328,0,2,0,5,1,6,-1,0,7,1,2,3,-0.001445709029212594,-0.4484794139862061,0.1037120968103409,0,2,0,8,2,8,-1,0,10,2,4,2,-0.004669508896768093,-0.6114224791526794,0.0632337629795074,0,2,3,0,28,6,-1,10,0,14,6,2,-0.004737180192023516,0.1570415049791336,-0.2723324000835419,0,2,14,17,12,2,-1,17,17,6,2,2,-0.005691098980605602,-0.6191142797470093,0.0814892426133156,0,2,14,7,12,7,-1,18,7,4,7,3,-0.0186615791171789,0.3149054050445557,-0.1412858963012695,0,2,18,18,12,2,-1,24,18,6,2,2,-0.00695282407104969,-0.5713124871253967,0.0768287181854248,0,2,14,7,12,8,-1,18,7,4,8,3,0.0201912708580494,-0.1205758005380631,0.3513692915439606,0,2,30,0,6,2,-1,33,0,3,2,2,-0.0008792306180112064,-0.3869098126888275,0.1025919020175934,1,2,34,10,4,4,-1,35,11,2,4,2,-0.006083448883146048,0.4049862921237946,-0.1020127013325691,0,2,39,9,1,8,-1,39,11,1,4,2,-0.0024388181045651436,-0.5900828242301941,0.0761464983224869,0,2,29,14,3,3,-1,29,15,3,1,3,0.002669439883902669,-0.0925890132784843,0.5280274748802185,1,2,7,0,4,6,-1,8,1,2,6,2,-0.00671631982550025,0.3635222017765045,-0.102479599416256,0,2,37,18,3,1,-1,38,18,1,1,3,-0.000192592095118016,-0.4895620048046112,0.0844633802771568,0,2,0,8,15,2,-1,5,8,5,2,3,-0.009959438815712929,0.3134663105010986,-0.139881506562233,0,2,14,17,24,3,-1,22,17,8,3,3,-0.002062930027022958,0.1871950030326843,-0.1989361047744751,0,2,3,2,21,6,-1,3,4,21,2,3,0.0183206796646118,-0.1083524003624916,0.3676620125770569,0,2,7,2,20,6,-1,7,4,20,2,3,-0.0373738296329975,0.3374510109424591,-0.1241820007562637,0,2,21,0,3,3,-1,22,0,1,3,3,0.0003442009910941124,0.0905127078294754,-0.4173887073993683,1,2,32,7,6,7,-1,34,9,2,7,3,-0.0247775707393885,0.391218900680542,-0.0958533734083176,0,3,31,13,8,4,-1,31,13,4,2,2,35,15,4,2,2,0.004383639898151159,-0.1190190985798836,0.319380909204483,0,2,3,19,6,1,-1,5,19,2,1,3,-0.0013420459581539035,-0.5415140986442566,0.0696717798709869,0,2,8,16,14,4,-1,8,17,14,2,2,-0.009481923654675484,0.3474692106246948,-0.1095890998840332,0,2,14,16,3,2,-1,14,17,3,1,2,0.0005324293742887676,-0.1411978006362915,0.284093588590622,0,2,0,0,2,3,-1,1,0,1,3,2,0.00023370010603684932,0.0937417894601822,-0.4010100960731506,0,2,0,0,3,2,-1,1,0,1,2,3,-0.0003639193018898368,-0.4783284068107605,0.0702429413795471,0,2,28,7,12,4,-1,28,9,12,2,2,-0.0158140007406473,-0.5980347990989685,0.0538051314651966,0,2,0,1,39,3,-1,0,2,39,1,3,-0.012278419919312,0.3658455014228821,-0.0990386307239532,-1.559838056564331,47,0,2,0,9,10,1,-1,5,9,5,1,2,0.0024346280843019485,-0.2992014884948731,0.384157806634903,0,3,32,12,8,8,-1,32,12,4,4,2,36,16,4,4,2,0.0103379096835852,-0.1800902932882309,0.3689959049224854,0,2,39,0,1,16,-1,39,8,1,8,2,0.003163421992212534,0.1128313019871712,-0.5044671297073364,0,2,1,17,6,3,-1,4,17,3,3,2,0.0007884561782702804,0.1576218008995056,-0.3924297094345093,0,2,24,2,16,8,-1,24,6,16,4,2,0.0228907596319914,-0.2257383018732071,0.2111188024282455,0,2,20,0,1,6,-1,20,3,1,3,2,-0.0009589929832145572,0.2502517104148865,-0.2970455884933472,0,2,0,6,1,8,-1,0,10,1,4,2,0.0014330829726532102,0.1594334989786148,-0.4450739026069641,0,2,0,8,22,4,-1,0,10,22,2,2,-0.0168796703219414,-0.5600076913833618,0.1078097000718117,1,2,33,8,6,6,-1,35,10,2,6,3,-0.0169947892427444,0.2922317087650299,-0.2028650045394898,0,2,16,19,9,1,-1,19,19,3,1,3,0.0018273950554430485,0.1414719969034195,-0.62185138463974,0,2,38,8,2,12,-1,38,12,2,4,3,-0.0131428297609091,-0.6497417092323303,0.0551953203976154,1,2,33,0,7,2,-1,33,0,7,1,2,-0.00957673043012619,0.6428776979446411,-0.0830350890755653,0,3,0,10,6,10,-1,0,10,3,5,2,3,15,3,5,2,0.003598768962547183,-0.143287405371666,0.3599688112735748,0,2,8,11,26,9,-1,8,14,26,3,3,-0.1358482986688614,0.4291998147964478,-0.1179091036319733,0,2,14,0,6,20,-1,14,5,6,10,2,0.1187063977122307,-0.0961144864559174,0.4932228028774262,0,2,0,0,2,18,-1,0,6,2,6,3,0.00250505399890244,0.1234757974743843,-0.3673230111598969,1,2,6,9,6,4,-1,5,10,6,2,2,0.007790023926645517,-0.1016507968306541,0.4558706879615784,0,2,36,7,4,6,-1,38,7,2,6,2,0.002124228049069643,-0.1267714947462082,0.3449754118919373,0,2,12,0,8,2,-1,14,0,4,2,2,-0.0020488998852670193,-0.6206071972846985,0.0743603408336639,0,2,8,0,9,2,-1,11,0,3,2,3,-0.004045784939080477,-0.6757919192314148,0.0515914410352707,1,2,6,1,3,4,-1,7,2,1,4,3,-0.004334962926805019,0.4410620033740997,-0.1000820994377136,0,2,21,14,14,5,-1,28,14,7,5,2,0.002321573905646801,-0.2301338016986847,0.178439199924469,0,2,12,18,15,2,-1,17,18,5,2,3,-0.009751113131642342,-0.6532456874847412,0.0684324279427528,1,2,8,0,8,8,-1,10,2,4,8,2,-0.0323445983231068,0.3332782089710236,-0.1391683965921402,0,2,8,2,2,6,-1,8,5,2,3,2,0.002736310940235853,-0.1446854025125504,0.2843329012393951,0,3,1,1,10,8,-1,1,1,5,4,2,6,5,5,4,2,-0.006390030030161142,0.3652864098548889,-0.1112807020545006,1,2,1,14,4,1,-1,2,15,2,1,2,0.0010396180441603065,0.0920357629656792,-0.4961740970611572,0,2,18,13,11,3,-1,18,14,11,1,3,0.0044716279953718185,-0.1323969066143036,0.3252590000629425,0,2,0,15,2,3,-1,0,16,2,1,3,-0.0009087984799407423,-0.4984821975231171,0.0782010927796364,0,2,9,13,21,3,-1,9,14,21,1,3,-0.008241133764386177,0.349206805229187,-0.1234752982854843,0,2,39,1,1,12,-1,39,5,1,4,3,-0.006856734864413738,-0.486938089132309,0.0809490084648132,0,2,39,3,1,8,-1,39,5,1,4,2,0.0009976780274882913,0.0848340317606926,-0.4335845112800598,1,2,32,0,8,3,-1,31,1,8,1,3,-0.0076758828945457935,0.4857445061206818,-0.0823790729045868,0,2,26,7,12,5,-1,30,7,4,5,3,-0.0116479899734259,0.3113785982131958,-0.131897896528244,0,2,35,18,3,2,-1,36,18,1,2,3,-0.0003181816136930138,-0.4828849136829376,0.0835208967328072,0,2,22,7,12,7,-1,26,7,4,7,3,-0.0175482295453548,0.303552508354187,-0.1289916932582855,0,2,35,17,3,3,-1,36,17,1,3,3,0.0003735019126906991,0.0928965583443642,-0.39392951130867,1,2,5,12,5,3,-1,4,13,5,1,3,0.004149334970861673,-0.0789389833807945,0.461139589548111,0,2,0,5,6,9,-1,0,8,6,3,3,-0.0232711806893349,-0.5966591238975525,0.0629077926278114,0,2,10,1,9,6,-1,10,3,9,2,3,0.005035512149333954,-0.1166566014289856,0.3193388879299164,0,2,15,2,3,2,-1,15,3,3,1,2,-0.0005637399153783917,0.2430483996868134,-0.1597543954849243,0,2,9,1,12,2,-1,12,1,6,2,2,0.0014867109712213278,0.1068094000220299,-0.393489807844162,0,2,0,7,6,8,-1,2,7,2,8,3,-0.014593799598515,0.3960965871810913,-0.0930664166808128,0,2,21,0,4,5,-1,22,0,2,5,2,-0.0017397500341758132,-0.5763638019561768,0.0675215572118759,0,2,18,0,9,6,-1,21,0,3,6,3,0.009002607315778732,0.0661495476961136,-0.535897970199585,0,2,28,18,1,2,-1,28,19,1,1,2,0.000019574859834392555,-0.2092854976654053,0.16840860247612,0,2,3,1,37,3,-1,3,2,37,1,3,-0.0076589807868003845,0.2978129982948303,-0.1177117004990578,-1.4044170379638672,44,0,2,3,0,21,12,-1,3,6,21,6,2,0.0780539512634277,-0.3325389921665192,0.3314310014247894,0,2,39,14,1,6,-1,39,17,1,3,2,-0.0009745802963152528,-0.530451774597168,0.1221980974078178,0,2,10,0,5,12,-1,10,6,5,6,2,0.1541665941476822,0.0275122094899416,873.6563110351562,0,2,21,9,16,9,-1,21,12,16,3,3,0.0177722591906786,-0.2716864049434662,0.258153110742569,0,2,0,1,1,16,-1,0,5,1,8,2,0.0026176879182457924,0.068688727915287,-0.6021304130554199,0,2,22,15,4,2,-1,22,16,4,1,2,0.0009777552913874388,-0.1404411047697067,0.4142614901065826,0,2,0,7,9,7,-1,3,7,3,7,3,-0.0216126702725887,0.3370456099510193,-0.1780340969562531,0,2,8,16,24,4,-1,14,16,12,4,2,-0.002058678073808551,0.2031076997518539,-0.2601813971996307,1,2,34,2,5,3,-1,33,3,5,1,3,0.004020370077341795,-0.1129515022039414,0.499021589756012,0,3,31,1,6,10,-1,31,1,3,5,2,34,6,3,5,2,-0.00792047381401062,0.3740311861038208,-0.1736444979906082,0,2,1,18,6,2,-1,4,18,3,2,2,0.0012068370124325156,0.1221465989947319,-0.5143222212791443,0,2,13,17,1,2,-1,13,18,1,1,2,0.000010062530236609746,-0.2223082929849625,0.2011664062738419,0,2,39,12,1,6,-1,39,14,1,2,3,-0.0013861319748684764,-0.537529706954956,0.0842030569911003,0,2,2,10,6,2,-1,4,10,2,2,3,0.0028477120213210583,-0.125826895236969,0.4183749854564667,0,2,13,2,15,2,-1,13,3,15,1,2,-0.001280845026485622,0.2209313958883286,-0.2100546061992645,1,2,31,0,9,2,-1,31,0,9,1,2,-0.007805110886693001,0.4776544868946075,-0.1113734021782875,0,2,19,0,16,20,-1,27,0,8,20,2,0.1868938952684403,0.0726455897092819,-0.696050226688385,0,2,38,13,2,1,-1,39,13,1,1,2,0.000009429650162928738,-0.183442696928978,0.2356549054384232,0,2,25,0,3,1,-1,26,0,1,1,3,0.0001592267071828246,0.1027031019330025,-0.4672388136386871,0,2,0,10,12,2,-1,4,10,4,2,3,-0.004951316863298416,0.2441108971834183,-0.1663984060287476,0,2,8,0,6,2,-1,10,0,2,2,3,0.0010822489857673645,0.0956272408366203,-0.5037704110145569,0,2,30,19,4,1,-1,32,19,2,1,2,-0.0008531155181117356,-0.6341928243637085,0.0583283081650734,0,2,33,3,7,12,-1,33,7,7,4,3,0.0546419285237789,0.0503404401242733,-0.6791167855262756,0,2,39,6,1,10,-1,39,11,1,5,2,0.0029848439153283834,0.0767069235444069,-0.4634890854358673,0,2,19,0,20,3,-1,29,0,10,3,2,-0.0056930831633508205,-0.3984872102737427,0.0919099673628807,1,2,2,0,4,2,-1,2,0,4,1,2,-0.004942999221384525,-0.6930655241012573,0.0454918593168259,1,2,35,1,5,3,-1,34,2,5,1,3,0.006958984769880772,-0.0747015625238419,0.5985698103904724,0,2,17,19,20,1,-1,22,19,10,1,2,-0.006175674963742495,-0.5511267185211182,0.0827933773398399,0,2,0,2,14,4,-1,7,2,7,4,2,-0.0028873051051050425,0.1743447035551071,-0.229966402053833,0,2,4,9,6,10,-1,6,9,2,10,3,0.0029177209362387657,-0.1558357030153275,0.290496289730072,0,2,7,9,32,8,-1,7,13,32,4,2,-0.131789892911911,0.3504653871059418,-0.1296782940626144,0,2,28,13,5,6,-1,28,15,5,2,3,0.0058290110900998116,-0.1132128015160561,0.443486213684082,0,2,26,14,8,4,-1,26,15,8,2,2,-0.0031782779842615128,0.2679023146629334,-0.1757756024599075,0,2,10,13,2,4,-1,10,14,2,2,2,0.00042928490438498557,-0.1497185975313187,0.2656292021274567,0,2,3,6,9,11,-1,6,6,3,11,3,-0.008150741457939148,0.2592093050479889,-0.1434807032346726,0,2,0,9,1,6,-1,0,12,1,3,2,0.0017238910077139735,0.077388808131218,-0.5167794227600098,0,2,38,2,2,2,-1,39,2,1,2,2,-0.00021709430438932031,-0.4221402108669281,0.0826049596071243,0,2,23,1,5,4,-1,23,2,5,2,2,0.0014374989550560713,-0.1189064010977745,0.340338408946991,0,2,25,0,5,6,-1,25,2,5,2,3,-0.004819538909941912,0.2423879057168961,-0.1488745957612991,0,2,17,16,18,4,-1,23,16,6,4,3,-0.0003520784084685147,0.1546490043401718,-0.238255500793457,0,2,31,18,3,2,-1,32,18,1,2,3,0.00034674329799599946,0.0871900320053101,-0.4105077087879181,1,2,6,0,3,5,-1,7,1,1,5,3,-0.007704629097133875,0.590129017829895,-0.0616974793374538,0,2,0,2,1,9,-1,0,5,1,3,3,-0.004356591030955315,-0.5103477835655212,0.0733159109950066,0,2,3,1,2,18,-1,3,7,2,6,3,-0.0116434702649713,0.2554587125778198,-0.1373805999755859,-1.4331510066986084,49,0,2,32,12,8,1,-1,36,12,4,1,2,-0.0018928770441561937,0.3834947943687439,-0.2579014897346497,0,2,3,2,14,18,-1,3,8,14,6,3,0.0809218287467957,-0.2536629140377045,0.2568750977516174,1,2,10,10,2,6,-1,10,10,2,3,2,0.070935919880867,0.00026506930589675903,-1034.9010009765625,0,2,5,3,33,16,-1,5,7,33,8,2,0.6601476073265076,-0.00014597430708818138,2471.365966796875,0,2,38,4,2,16,-1,38,12,2,8,2,-0.008943451568484306,-0.5130704045295715,0.1228426992893219,0,2,20,18,1,2,-1,20,19,1,1,2,0.000008648842594993766,-0.2739500105381012,0.230955496430397,0,2,27,5,12,8,-1,31,5,4,8,3,-0.0185032300651073,0.3430772125720978,-0.1713628023862839,0,2,39,0,1,20,-1,39,10,1,10,2,0.003951757214963436,0.1229270994663239,-0.5058156847953796,0,2,0,0,4,3,-1,2,0,2,3,2,0.0005485623842105269,0.0864181369543076,-0.4976634979248047,0,2,22,19,4,1,-1,24,19,2,1,2,-0.0004971270100213587,-0.5213550925254822,0.1004771962761879,0,2,15,16,1,2,-1,15,17,1,1,2,0.0003026447957381606,-0.1517993062734604,0.354915201663971,0,2,26,7,12,8,-1,30,7,4,8,3,0.0442832298576832,-0.1243626028299332,0.4159761071205139,0,2,24,6,12,8,-1,28,6,4,8,3,-0.0317893698811531,0.4141708016395569,-0.1250036954879761,0,2,2,18,6,1,-1,5,18,3,1,2,0.0003773575881496072,0.1291034072637558,-0.395176112651825,1,2,6,0,8,6,-1,8,2,4,6,2,-0.0354853607714176,0.4372386932373047,-0.1214715987443924,0,2,2,4,4,13,-1,4,4,2,13,2,0.0186434406787157,-0.088902972638607,0.4968973994255066,1,2,23,0,2,2,-1,23,0,2,1,2,0.00032789920805953443,-0.2337197959423065,0.209619402885437,0,2,4,0,24,1,-1,12,0,8,1,3,0.0018254360184073448,0.1128600984811783,-0.4249314963817596,0,2,18,0,21,2,-1,25,0,7,2,3,0.005742560140788555,0.0922185778617859,-0.5159558057785034,0,2,23,1,13,4,-1,23,2,13,2,2,0.002556995954364538,-0.1287899017333984,0.394408792257309,0,2,26,2,6,6,-1,26,5,6,3,2,0.00918745156377554,-0.169513002038002,0.2667942941188812,0,2,5,12,1,8,-1,5,16,1,4,2,0.0013819739688187838,-0.1626719981431961,0.3144749104976654,1,2,15,6,10,3,-1,15,6,5,3,2,0.0762646272778511,-0.0511168614029884,0.6940724849700928,0,2,7,4,20,4,-1,12,4,10,4,2,-0.00989215262234211,0.3261345028877258,-0.1333453953266144,0,2,14,13,12,3,-1,14,14,12,1,3,0.002893351949751377,-0.1386391967535019,0.3280135095119476,0,2,18,13,6,3,-1,18,14,6,1,3,-0.001459375023841858,0.2865088880062103,-0.1666216999292374,0,2,0,5,1,4,-1,0,7,1,2,2,0.0008613120880909264,0.083895243704319,-0.5724359750747681,1,2,2,12,6,2,-1,2,12,3,2,2,-0.0124032301828265,-0.5459722876548767,0.0659503489732742,1,2,5,10,5,4,-1,4,11,5,2,2,0.006110419984906912,-0.096364788711071,0.5005930066108704,1,2,36,10,4,6,-1,36,10,2,6,2,-0.019543120637536,0.5514221787452698,-0.0688779577612877,0,2,13,8,12,5,-1,17,8,4,5,3,0.0158339403569698,-0.1065464988350868,0.3985854983329773,0,2,1,0,4,2,-1,2,0,2,2,2,-0.00046764558646827936,-0.4591464996337891,0.0930821672081947,0,2,39,2,1,9,-1,39,5,1,3,3,-0.005390095058828592,-0.6202877163887024,0.0587204284965992,0,2,0,18,3,2,-1,1,18,1,2,3,0.00020217290148139,0.1030296012759209,-0.3769339025020599,0,2,31,16,1,2,-1,31,17,1,1,2,-0.00045046009472571313,0.4020825922489166,-0.1042373031377792,0,2,15,6,9,7,-1,18,6,3,7,3,-0.005292982794344425,0.2849242985248566,-0.1570533961057663,0,2,8,0,25,9,-1,8,3,25,3,3,-0.1651804000139237,0.5865985155105591,-0.0683702901005745,0,2,8,2,30,7,-1,18,2,10,7,3,-0.1367674022912979,-0.6619887948036194,0.0699269101023674,1,2,34,0,6,2,-1,34,0,6,1,2,-0.007522047962993383,0.6367573142051697,-0.0831320211291313,0,2,38,6,2,12,-1,39,6,1,12,2,0.000009894733921100851,-0.1907531023025513,0.221810594201088,0,2,30,5,10,9,-1,30,8,10,3,3,-0.035201508551836,-0.5618926286697388,0.0739409476518631,1,2,2,14,2,2,-1,2,14,2,1,2,0.0005346243269741535,0.0961733534932137,-0.4069541990756989,0,2,6,13,27,6,-1,6,15,27,2,3,-0.0904320627450943,0.5201839208602905,-0.0775950700044632,0,2,15,16,1,2,-1,15,17,1,1,2,-0.0002871844044420868,0.320431113243103,-0.1276845932006836,0,2,0,18,3,2,-1,1,18,1,2,3,-0.00009112853877013549,-0.303320586681366,0.1313142031431198,0,2,4,4,1,2,-1,4,5,1,1,2,-0.00000955523137236014,0.1980203986167908,-0.2060144990682602,0,2,21,3,12,3,-1,21,4,12,1,3,0.0033215670846402645,-0.1025642976164818,0.3913365006446838,0,2,1,16,3,1,-1,2,16,1,1,3,-0.00007808548980392516,-0.2856656908988953,0.1349948048591614,0,2,23,1,7,3,-1,23,2,7,1,3,0.001807252992875874,-0.0990281030535698,0.3741456866264343,-0.8944408893585205,15,0,2,23,0,14,5,-1,30,0,7,5,2,0.0036609990056604147,-0.4147176146507263,0.3035793006420136,1,2,38,11,2,2,-1,38,11,1,2,2,0.002576064085587859,-0.2113921940326691,0.6350064873695374,0,2,1,15,15,2,-1,1,16,15,1,2,-0.002527170116081834,0.3865292072296143,-0.2844916880130768,0,2,39,0,1,6,-1,39,3,1,3,2,0.001364656025543809,0.1571179032325745,-0.6689929962158203,0,2,3,1,15,8,-1,3,5,15,4,2,0.0418302491307259,-0.2187377959489822,0.6301587820053101,0,2,0,4,8,4,-1,4,4,4,4,2,-0.006136810872703791,0.5870814919471741,-0.2432383000850678,0,2,35,13,3,1,-1,36,13,1,1,3,-0.000278306397376582,0.6054819226264954,-0.1650584936141968,0,2,27,19,12,1,-1,31,19,4,1,3,-0.0019233929924666882,-0.5925003290176392,0.1991329938173294,0,2,28,14,12,2,-1,34,14,6,2,2,0.008123984560370445,-0.274422287940979,0.4660489857196808,0,2,16,2,11,3,-1,16,3,11,1,3,0.002673995913937688,-0.1800000071525574,0.677447497844696,0,2,8,17,21,3,-1,15,17,7,3,3,0.0154209500178695,0.1510500013828278,-0.7987899780273438,1,2,4,12,4,3,-1,3,13,4,1,3,-0.0053424229845404625,0.6468778848648071,-0.199910506606102,0,3,0,0,24,18,-1,0,0,12,9,2,12,9,12,9,2,-0.0500877499580383,-0.5540599822998047,0.2104005962610245,0,2,21,8,7,10,-1,21,13,7,5,2,-0.0157331507652998,0.2255475074052811,-0.4712851047515869,0,2,26,4,9,11,-1,29,4,3,11,3,0.0158580392599106,-0.2605768144130707,0.4887737035751343,-0.8740714192390442,13,1,2,36,14,2,2,-1,36,14,1,2,2,0.0036003149580210447,-0.1489852070808411,1.0001749992370605,0,3,33,3,4,2,-1,33,3,2,1,2,35,4,2,1,2,0.0007585806888528168,-0.131798192858696,0.8709139227867126,0,2,6,0,24,2,-1,14,0,8,2,3,0.003843418089672923,0.2940030097961426,-0.4949179887771606,1,2,14,2,4,2,-1,15,3,2,2,2,-0.0017415370093658566,0.4998373985290527,-0.273226797580719,0,2,39,2,1,18,-1,39,11,1,9,2,-0.004034561105072498,-0.6480407118797302,0.2333527952432632,0,2,23,2,11,4,-1,23,3,11,2,2,0.0046522729098796844,-0.2006133049726486,0.6975126266479492,0,2,16,2,15,3,-1,16,3,15,1,3,-0.007543866988271475,0.6717798709869385,-0.1906248927116394,0,2,12,16,1,2,-1,12,17,1,1,2,-0.00023316270380746573,0.5406453013420105,-0.2451383024454117,1,2,25,1,4,3,-1,24,2,4,1,3,-0.0029374239966273308,0.6680412292480469,-0.2204574942588806,0,2,0,11,2,3,-1,1,11,1,3,2,-0.00004402159174787812,0.3765692114830017,-0.3855428993701935,0,2,14,4,8,12,-1,16,4,4,12,2,0.007473721168935299,-0.1633331030607224,0.8430562019348145,0,2,26,12,8,8,-1,30,12,4,8,2,0.0037062750197947025,-0.4001047015190125,0.3631373047828674,0,2,17,17,12,2,-1,21,17,4,2,3,-0.004233239218592644,-0.5669562816619873,0.2709982097148895,-1.222586989402771,9,0,2,8,4,20,2,-1,13,4,10,2,2,-0.0112955598160625,0.8996198177337646,-0.2501955032348633,0,2,39,1,1,15,-1,39,6,1,5,3,0.0005774110904894769,0.4419000148773193,-0.4728563129901886,0,2,3,7,9,2,-1,3,8,9,1,2,-0.0014991649659350514,-0.6489337086677551,0.3610076010227203,0,2,0,0,22,2,-1,11,0,11,2,2,0.008214366622269154,0.3602151870727539,-0.7518252730369568,0,3,33,5,4,4,-1,33,5,2,2,2,35,7,2,2,2,0.00040721948607824743,-0.3494193851947784,0.8262701034545898,0,3,7,9,20,2,-1,7,9,10,1,2,17,10,10,1,2,0.0017949739703908563,0.4154107868671417,-0.6663243174552917,0,2,38,4,2,4,-1,39,4,1,4,2,0.00004034083031001501,-0.3772572875022888,0.7400578260421753,1,2,36,0,4,2,-1,36,0,4,1,2,-0.0033845799043774605,0.8487367033958435,-0.2977770864963532,0,2,3,0,6,1,-1,5,0,2,1,3,0.0002836200001183897,0.5246902108192444,-0.5165300965309143,-0.554408609867096,6,0,2,16,3,16,2,-1,20,3,8,2,2,-0.0008382584201171994,0.8660088181495667,-0.4131587147712708,0,2,39,6,1,10,-1,39,11,1,5,2,-0.0011254430282860994,-0.5735393166542053,0.5828214883804321,0,2,12,16,16,3,-1,20,16,8,3,2,-0.0236753299832344,-0.9092180728912354,0.4056020975112915,1,2,15,2,4,2,-1,16,3,2,2,2,-0.0015190989943221211,1,-0.4600743055343628,0,3,12,4,12,14,-1,12,4,6,7,2,18,11,6,7,2,-0.009333798661828041,-0.3659012913703919,0.9999818205833435,0,2,31,5,3,13,-1,32,5,1,13,3,-0.0004129564040340483,1,-0.2680450975894928,1.0002059936523438,1,0,2,0,11,36,9,-1,9,11,18,9,2,-0.1850994974374771,-0.9920324087142944,1.0002059936523438];
//var tracking = require('Processing/tracking.js');
//import tracking from 'Processing/tracking.js';
//import tracking from 'tracking';
//import _ from 'tracking';
//import tracking = require('tracking');





/**
 * tracking - A modern approach for Computer Vision on the web.
 * @author Eduardo Lundgren <edu@rdo.io>
 * @version v1.1.2
 * @link http://trackingjs.com
 * @license BSD
 */
(function(window, undefined) {
  window.tracking = window.tracking || {};

  /**
   * Inherit the prototype methods from one constructor into another.
   *
   * Usage:
   * <pre>
   * function ParentClass(a, b) { }
   * ParentClass.prototype.foo = function(a) { }
   *
   * function ChildClass(a, b, c) {
   *   tracking.base(this, a, b);
   * }
   * tracking.inherits(ChildClass, ParentClass);
   *
   * var child = new ChildClass('a', 'b', 'c');
   * child.foo();
   * </pre>
   *
   * @param {Function} childCtor Child class.
   * @param {Function} parentCtor Parent class.
   */
  tracking.inherits = function(childCtor, parentCtor) {
    function TempCtor() {
    }
    TempCtor.prototype = parentCtor.prototype;
    childCtor.superClass_ = parentCtor.prototype;
    childCtor.prototype = new TempCtor();
    childCtor.prototype.constructor = childCtor;

    /**
     * Calls superclass constructor/method.
     *
     * This function is only available if you use tracking.inherits to express
     * inheritance relationships between classes.
     *
     * @param {!object} me Should always be "this".
     * @param {string} methodName The method name to call. Calling superclass
     *     constructor can be done with the special string 'constructor'.
     * @param {...*} var_args The arguments to pass to superclass
     *     method/constructor.
     * @return {*} The return value of the superclass method/constructor.
     */
    childCtor.base = function(me, methodName) {
      var args = Array.prototype.slice.call(arguments, 2);
      return parentCtor.prototype[methodName].apply(me, args);
    };
  };

  /**
   * Captures the user camera when tracking a video element and set its source
   * to the camera stream.
   * @param {HTMLVideoElement} element Canvas element to track.
   * @param {object} opt_options Optional configuration to the tracker.
   */
  tracking.initUserMedia_ = function(element, opt_options) {
    window.navigator.getUserMedia({
      video: true,
      audio: !!(opt_options && opt_options.audio)
    }, function(stream) {
        try {
          element.src = window.URL.createObjectURL(stream);
        } catch (err) {
          element.src = stream;
        }
      }, function() {
        throw Error('Cannot capture user camera.');
      }
    );
  };

  /**
   * Tests whether the object is a dom node.
   * @param {object} o Object to be tested.
   * @return {boolean} True if the object is a dom node.
   */
  tracking.isNode = function(o) {
    return o.nodeType || this.isWindow(o);
  };

  /**
   * Tests whether the object is the `window` object.
   * @param {object} o Object to be tested.
   * @return {boolean} True if the object is the `window` object.
   */
  tracking.isWindow = function(o) {
    return !!(o && o.alert && o.document);
  };

  /**
   * Selects a dom node from a CSS3 selector using `document.querySelector`.
   * @param {string} selector
   * @param {object} opt_element The root element for the query. When not
   *     specified `document` is used as root element.
   * @return {HTMLElement} The first dom element that matches to the selector.
   *     If not found, returns `null`.
   */
  tracking.one = function(selector, opt_element) {
    if (this.isNode(selector)) {
      return selector;
    }
    return (opt_element || document).querySelector(selector);
  };

  /**
   * Tracks a canvas, image or video element based on the specified `tracker`
   * instance. This method extract the pixel information of the input element
   * to pass to the `tracker` instance. When tracking a video, the
   * `tracker.track(pixels, width, height)` will be in a
   * `requestAnimationFrame` loop in order to track all video frames.
   *
   * Example:
   * var tracker = new tracking.ColorTracker();
   *
   * tracking.track('#video', tracker);
   * or
   * tracking.track('#video', tracker, { camera: true });
   *
   * tracker.on('track', function(event) {
   *   // console.log(event.data[0].x, event.data[0].y)
   * });
   *
   * @param {HTMLElement} element The element to track, canvas, image or
   *     video.
   * @param {tracking.Tracker} tracker The tracker instance used to track the
   *     element.
   * @param {object} opt_options Optional configuration to the tracker.
   */
  tracking.track = function(element, tracker, opt_options) {
    element = tracking.one(element);
    if (!element) {
      throw new Error('Element not found, try a different element or selector.');
    }
    if (!tracker) {
      throw new Error('Tracker not specified, try `tracking.track(element, new tracking.FaceTracker())`.');
    }

    switch (element.nodeName.toLowerCase()) {
      case 'canvas':
        return this.trackCanvas_(element, tracker, opt_options);
      case 'img':
        return this.trackImg_(element, tracker, opt_options);
      case 'video':
        if (opt_options) {
          if (opt_options.camera) {
            this.initUserMedia_(element, opt_options);
          }
        }
        return this.trackVideo_(element, tracker, opt_options);
      default:
        throw new Error('Element not supported, try in a canvas, img, or video.');
    }
  };

  /**
   * Tracks a canvas element based on the specified `tracker` instance and
   * returns a `TrackerTask` for this track.
   * @param {HTMLCanvasElement} element Canvas element to track.
   * @param {tracking.Tracker} tracker The tracker instance used to track the
   *     element.
   * @param {object} opt_options Optional configuration to the tracker.
   * @return {tracking.TrackerTask}
   * @private
   */
  tracking.trackCanvas_ = function(element, tracker) {
    var self = this;
    var task = new tracking.TrackerTask(tracker);
    task.on('run', function() {
      self.trackCanvasInternal_(element, tracker);
    });
    return task.run();
  };

  /**
   * Tracks a canvas element based on the specified `tracker` instance. This
   * method extract the pixel information of the input element to pass to the
   * `tracker` instance.
   * @param {HTMLCanvasElement} element Canvas element to track.
   * @param {tracking.Tracker} tracker The tracker instance used to track the
   *     element.
   * @param {object} opt_options Optional configuration to the tracker.
   * @private
   */
  tracking.trackCanvasInternal_ = function(element, tracker) {
    var width = element.width;
    var height = element.height;
    var context = element.getContext('2d');
    var imageData = context.getImageData(0, 0, width, height);
    tracker.track(imageData.data, width, height);
  };

  /**
   * Tracks a image element based on the specified `tracker` instance. This
   * method extract the pixel information of the input element to pass to the
   * `tracker` instance.
   * @param {HTMLImageElement} element Canvas element to track.
   * @param {tracking.Tracker} tracker The tracker instance used to track the
   *     element.
   * @param {object} opt_options Optional configuration to the tracker.
   * @private
   */
  tracking.trackImg_ = function(element, tracker) {
    var width = element.width;
    var height = element.height;
    var canvas = document.createElement('canvas');

    canvas.width = width;
    canvas.height = height;

    var task = new tracking.TrackerTask(tracker);
    task.on('run', function() {
      tracking.Canvas.loadImage(canvas, element.src, 0, 0, width, height, function() {
        tracking.trackCanvasInternal_(canvas, tracker);
      });
    });
    return task.run();
  };

  /**
   * Tracks a video element based on the specified `tracker` instance. This
   * method extract the pixel information of the input element to pass to the
   * `tracker` instance. The `tracker.track(pixels, width, height)` will be in
   * a `requestAnimationFrame` loop in order to track all video frames.
   * @param {HTMLVideoElement} element Canvas element to track.
   * @param {tracking.Tracker} tracker The tracker instance used to track the
   *     element.
   * @param {object} opt_options Optional configuration to the tracker.
   * @private
   */
  tracking.trackVideo_ = function(element, tracker) {
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    var width;
    var height;

    var resizeCanvas_ = function() {
      width = element.offsetWidth;
      height = element.offsetHeight;
      canvas.width = width;
      canvas.height = height;
    };
    resizeCanvas_();
    element.addEventListener('resize', resizeCanvas_);

    var requestId;
    var requestAnimationFrame_ = function() {
      requestId = window.requestAnimationFrame(function() {
        if (element.readyState === element.HAVE_ENOUGH_DATA) {
          try {
            // Firefox v~30.0 gets confused with the video readyState firing an
            // erroneous HAVE_ENOUGH_DATA just before HAVE_CURRENT_DATA state,
            // hence keep trying to read it until resolved.
            context.drawImage(element, 0, 0, width, height);
          } catch (err) {}
          tracking.trackCanvasInternal_(canvas, tracker);
        }
        requestAnimationFrame_();
      });
    };

    var task = new tracking.TrackerTask(tracker);
    task.on('stop', function() {
      window.cancelAnimationFrame(requestId);
    });
    task.on('run', function() {
      requestAnimationFrame_();
    });
    return task.run();
  };

  // Browser polyfills
  //===================

  if (!window.URL) {
    window.URL = window.URL || window.webkitURL || window.msURL || window.oURL;
  }

  if (!navigator.getUserMedia) {
    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia ||
    navigator.mozGetUserMedia || navigator.msGetUserMedia;
  }
}(window));

(function() {
  /**
   * EventEmitter utility.
   * @constructor
   */
  tracking.EventEmitter = function() {};

  /**
   * Holds event listeners scoped by event type.
   * @type {object}
   * @private
   */
  tracking.EventEmitter.prototype.events_ = null;

  /**
   * Adds a listener to the end of the listeners array for the specified event.
   * @param {string} event
   * @param {function} listener
   * @return {object} Returns emitter, so calls can be chained.
   */
  tracking.EventEmitter.prototype.addListener = function(event, listener) {
    if (typeof listener !== 'function') {
      throw new TypeError('Listener must be a function');
    }
    if (!this.events_) {
      this.events_ = {};
    }

    this.emit('newListener', event, listener);

    if (!this.events_[event]) {
      this.events_[event] = [];
    }

    this.events_[event].push(listener);

    return this;
  };

  /**
   * Returns an array of listeners for the specified event.
   * @param {string} event
   * @return {array} Array of listeners.
   */
  tracking.EventEmitter.prototype.listeners = function(event) {
    return this.events_ && this.events_[event];
  };

  /**
   * Execute each of the listeners in order with the supplied arguments.
   * @param {string} event
   * @param {*} opt_args [arg1], [arg2], [...]
   * @return {boolean} Returns true if event had listeners, false otherwise.
   */
  tracking.EventEmitter.prototype.emit = function(event) {
    var listeners = this.listeners(event);
    if (listeners) {
      var args = Array.prototype.slice.call(arguments, 1);
      for (var i = 0; i < listeners.length; i++) {
        if (listeners[i]) {
          listeners[i].apply(this, args);
        }
      }
      return true;
    }
    return false;
  };

  /**
   * Adds a listener to the end of the listeners array for the specified event.
   * @param {string} event
   * @param {function} listener
   * @return {object} Returns emitter, so calls can be chained.
   */
  tracking.EventEmitter.prototype.on = tracking.EventEmitter.prototype.addListener;

  /**
   * Adds a one time listener for the event. This listener is invoked only the
   * next time the event is fired, after which it is removed.
   * @param {string} event
   * @param {function} listener
   * @return {object} Returns emitter, so calls can be chained.
   */
  tracking.EventEmitter.prototype.once = function(event, listener) {
    var self = this;
    self.on(event, function handlerInternal() {
      self.removeListener(event, handlerInternal);
      listener.apply(this, arguments);
    });
  };

  /**
   * Removes all listeners, or those of the specified event. It's not a good
   * idea to remove listeners that were added elsewhere in the code,
   * especially when it's on an emitter that you didn't create.
   * @param {string} event
   * @return {object} Returns emitter, so calls can be chained.
   */
  tracking.EventEmitter.prototype.removeAllListeners = function(opt_event) {
    if (!this.events_) {
      return this;
    }
    if (opt_event) {
      delete this.events_[opt_event];
    } else {
      delete this.events_;
    }
    return this;
  };

  /**
   * Remove a listener from the listener array for the specified event.
   * Caution: changes array indices in the listener array behind the listener.
   * @param {string} event
   * @param {function} listener
   * @return {object} Returns emitter, so calls can be chained.
   */
  tracking.EventEmitter.prototype.removeListener = function(event, listener) {
    if (typeof listener !== 'function') {
      throw new TypeError('Listener must be a function');
    }
    if (!this.events_) {
      return this;
    }

    var listeners = this.listeners(event);
    if (Array.isArray(listeners)) {
      var i = listeners.indexOf(listener);
      if (i < 0) {
        return this;
      }
      listeners.splice(i, 1);
    }

    return this;
  };

  /**
   * By default EventEmitters will print a warning if more than 10 listeners
   * are added for a particular event. This is a useful default which helps
   * finding memory leaks. Obviously not all Emitters should be limited to 10.
   * This function allows that to be increased. Set to zero for unlimited.
   * @param {number} n The maximum number of listeners.
   */
  tracking.EventEmitter.prototype.setMaxListeners = function() {
    throw new Error('Not implemented');
  };

}());

(function() {
  /**
   * Canvas utility.
   * @static
   * @constructor
   */
  tracking.Canvas = {};

  /**
   * Loads an image source into the canvas.
   * @param {HTMLCanvasElement} canvas The canvas dom element.
   * @param {string} src The image source.
   * @param {number} x The canvas horizontal coordinate to load the image.
   * @param {number} y The canvas vertical coordinate to load the image.
   * @param {number} width The image width.
   * @param {number} height The image height.
   * @param {function} opt_callback Callback that fires when the image is loaded
   *     into the canvas.
   * @static
   */
  tracking.Canvas.loadImage = function(canvas, src, x, y, width, height, opt_callback) {
    var instance = this;
    var img = new window.Image();
    img.crossOrigin = '*';
    img.onload = function() {
      var context = canvas.getContext('2d');
      canvas.width = width;
      canvas.height = height;
      context.drawImage(img, x, y, width, height);
      if (opt_callback) {
        opt_callback.call(instance);
      }
      img = null;
    };
    img.src = src;
  };
}());

(function() {
  /**
   * DisjointSet utility with path compression. Some applications involve
   * grouping n distinct objects into a collection of disjoint sets. Two
   * important operations are then finding which set a given object belongs to
   * and uniting the two sets. A disjoint set data structure maintains a
   * collection S={ S1 , S2 ,..., Sk } of disjoint dynamic sets. Each set is
   * identified by a representative, which usually is a member in the set.
   * @static
   * @constructor
   */
  tracking.DisjointSet = function(length) {
    if (length === undefined) {
      throw new Error('DisjointSet length not specified.');
    }
    this.length = length;
    this.parent = new Uint32Array(length);
    for (var i = 0; i < length; i++) {
      this.parent[i] = i;
    }
  };

  /**
   * Holds the length of the internal set.
   * @type {number}
   */
  tracking.DisjointSet.prototype.length = null;

  /**
   * Holds the set containing the representative values.
   * @type {Array.<number>}
   */
  tracking.DisjointSet.prototype.parent = null;

  /**
   * Finds a pointer to the representative of the set containing i.
   * @param {number} i
   * @return {number} The representative set of i.
   */
  tracking.DisjointSet.prototype.find = function(i) {
    if (this.parent[i] === i) {
      return i;
    } else {
      return (this.parent[i] = this.find(this.parent[i]));
    }
  };

  /**
   * Unites two dynamic sets containing objects i and j, say Si and Sj, into
   * a new set that Si  Sj, assuming that Si  Sj = ;
   * @param {number} i
   * @param {number} j
   */
  tracking.DisjointSet.prototype.union = function(i, j) {
    var iRepresentative = this.find(i);
    var jRepresentative = this.find(j);
    this.parent[iRepresentative] = jRepresentative;
  };

}());

(function() {
  /**
   * Image utility.
   * @static
   * @constructor
   */
  tracking.Image = {};

  /**
   * Computes gaussian blur. Adapted from
   * https://github.com/kig/canvasfilters.
   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.
   * @param {number} width The image width.
   * @param {number} height The image height.
   * @param {number} diameter Gaussian blur diameter, must be greater than 1.
   * @return {array} The edge pixels in a linear [r,g,b,a,...] array.
   */
  tracking.Image.blur = function(pixels, width, height, diameter) {
    diameter = Math.abs(diameter);
    if (diameter <= 1) {
      throw new Error('Diameter should be greater than 1.');
    }
    var radius = diameter / 2;
    var len = Math.ceil(diameter) + (1 - (Math.ceil(diameter) % 2));
    var weights = new Float32Array(len);
    var rho = (radius + 0.5) / 3;
    var rhoSq = rho * rho;
    var gaussianFactor = 1 / Math.sqrt(2 * Math.PI * rhoSq);
    var rhoFactor = -1 / (2 * rho * rho);
    var wsum = 0;
    var middle = Math.floor(len / 2);
    for (var i = 0; i < len; i++) {
      var x = i - middle;
      var gx = gaussianFactor * Math.exp(x * x * rhoFactor);
      weights[i] = gx;
      wsum += gx;
    }
    for (var j = 0; j < weights.length; j++) {
      weights[j] /= wsum;
    }
    return this.separableConvolve(pixels, width, height, weights, weights, false);
  };

  /**
   * Computes the integral image for summed, squared, rotated and sobel pixels.
   * @param {array} pixels The pixels in a linear [r,g,b,a,...] array to loop
   *     through.
   * @param {number} width The image width.
   * @param {number} height The image height.
   * @param {array} opt_integralImage Empty array of size `width * height` to
   *     be filled with the integral image values. If not specified compute sum
   *     values will be skipped.
   * @param {array} opt_integralImageSquare Empty array of size `width *
   *     height` to be filled with the integral image squared values. If not
   *     specified compute squared values will be skipped.
   * @param {array} opt_tiltedIntegralImage Empty array of size `width *
   *     height` to be filled with the rotated integral image values. If not
   *     specified compute sum values will be skipped.
   * @param {array} opt_integralImageSobel Empty array of size `width *
   *     height` to be filled with the integral image of sobel values. If not
   *     specified compute sobel filtering will be skipped.
   * @static
   */
  tracking.Image.computeIntegralImage = function(pixels, width, height, opt_integralImage, opt_integralImageSquare, opt_tiltedIntegralImage, opt_integralImageSobel) {
    if (arguments.length < 4) {
      throw new Error('You should specify at least one output array in the order: sum, square, tilted, sobel.');
    }
    var pixelsSobel;
    if (opt_integralImageSobel) {
      pixelsSobel = tracking.Image.sobel(pixels, width, height);
    }
    for (var i = 0; i < height; i++) {
      for (var j = 0; j < width; j++) {
        var w = i * width * 4 + j * 4;
        var pixel = ~~(pixels[w] * 0.299 + pixels[w + 1] * 0.587 + pixels[w + 2] * 0.114);
        if (opt_integralImage) {
          this.computePixelValueSAT_(opt_integralImage, width, i, j, pixel);
        }
        if (opt_integralImageSquare) {
          this.computePixelValueSAT_(opt_integralImageSquare, width, i, j, pixel * pixel);
        }
        if (opt_tiltedIntegralImage) {
          var w1 = w - width * 4;
          var pixelAbove = ~~(pixels[w1] * 0.299 + pixels[w1 + 1] * 0.587 + pixels[w1 + 2] * 0.114);
          this.computePixelValueRSAT_(opt_tiltedIntegralImage, width, i, j, pixel, pixelAbove || 0);
        }
        if (opt_integralImageSobel) {
          this.computePixelValueSAT_(opt_integralImageSobel, width, i, j, pixelsSobel[w]);
        }
      }
    }
  };

  /**
   * Helper method to compute the rotated summed area table (RSAT) by the
   * formula:
   *
   * RSAT(x, y) = RSAT(x-1, y-1) + RSAT(x+1, y-1) - RSAT(x, y-2) + I(x, y) + I(x, y-1)
   *
   * @param {number} width The image width.
   * @param {array} RSAT Empty array of size `width * height` to be filled with
   *     the integral image values. If not specified compute sum values will be
   *     skipped.
   * @param {number} i Vertical position of the pixel to be evaluated.
   * @param {number} j Horizontal position of the pixel to be evaluated.
   * @param {number} pixel Pixel value to be added to the integral image.
   * @static
   * @private
   */
  tracking.Image.computePixelValueRSAT_ = function(RSAT, width, i, j, pixel, pixelAbove) {
    var w = i * width + j;
    RSAT[w] = (RSAT[w - width - 1] || 0) + (RSAT[w - width + 1] || 0) - (RSAT[w - width - width] || 0) + pixel + pixelAbove;
  };

  /**
   * Helper method to compute the summed area table (SAT) by the formula:
   *
   * SAT(x, y) = SAT(x, y-1) + SAT(x-1, y) + I(x, y) - SAT(x-1, y-1)
   *
   * @param {number} width The image width.
   * @param {array} SAT Empty array of size `width * height` to be filled with
   *     the integral image values. If not specified compute sum values will be
   *     skipped.
   * @param {number} i Vertical position of the pixel to be evaluated.
   * @param {number} j Horizontal position of the pixel to be evaluated.
   * @param {number} pixel Pixel value to be added to the integral image.
   * @static
   * @private
   */
  tracking.Image.computePixelValueSAT_ = function(SAT, width, i, j, pixel) {
    var w = i * width + j;
    SAT[w] = (SAT[w - width] || 0) + (SAT[w - 1] || 0) + pixel - (SAT[w - width - 1] || 0);
  };

  /**
   * Converts a color from a colorspace based on an RGB color model to a
   * grayscale representation of its luminance. The coefficients represent the
   * measured intensity perception of typical trichromat humans, in
   * particular, human vision is most sensitive to green and least sensitive
   * to blue.
   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.
   * @param {number} width The image width.
   * @param {number} height The image height.
   * @param {boolean} fillRGBA If the result should fill all RGBA values with the gray scale
   *  values, instead of returning a single value per pixel.
   * @param {Uint8ClampedArray} The grayscale pixels in a linear array ([p,p,p,a,...] if fillRGBA
   *  is true and [p1, p2, p3, ...] if fillRGBA is false).
   * @static
   */
  tracking.Image.grayscale = function(pixels, width, height, fillRGBA) {
    var gray = new Uint8ClampedArray(fillRGBA ? pixels.length : pixels.length >> 2);
    var p = 0;
    var w = 0;
    for (var i = 0; i < height; i++) {
      for (var j = 0; j < width; j++) {
        var value = pixels[w] * 0.299 + pixels[w + 1] * 0.587 + pixels[w + 2] * 0.114;
        gray[p++] = value;

        if (fillRGBA) {
          gray[p++] = value;
          gray[p++] = value;
          gray[p++] = pixels[w + 3];
        }

        w += 4;
      }
    }
    return gray;
  };

  /**
   * Fast horizontal separable convolution. A point spread function (PSF) is
   * said to be separable if it can be broken into two one-dimensional
   * signals: a vertical and a horizontal projection. The convolution is
   * performed by sliding the kernel over the image, generally starting at the
   * top left corner, so as to move the kernel through all the positions where
   * the kernel fits entirely within the boundaries of the image. Adapted from
   * https://github.com/kig/canvasfilters.
   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.
   * @param {number} width The image width.
   * @param {number} height The image height.
   * @param {array} weightsVector The weighting vector, e.g [-1,0,1].
   * @param {number} opaque
   * @return {array} The convoluted pixels in a linear [r,g,b,a,...] array.
   */
  tracking.Image.horizontalConvolve = function(pixels, width, height, weightsVector, opaque) {
    var side = weightsVector.length;
    var halfSide = Math.floor(side / 2);
    var output = new Float32Array(width * height * 4);
    var alphaFac = opaque ? 1 : 0;

    for (var y = 0; y < height; y++) {
      for (var x = 0; x < width; x++) {
        var sy = y;
        var sx = x;
        var offset = (y * width + x) * 4;
        var r = 0;
        var g = 0;
        var b = 0;
        var a = 0;
        for (var cx = 0; cx < side; cx++) {
          var scy = sy;
          var scx = Math.min(width - 1, Math.max(0, sx + cx - halfSide));
          var poffset = (scy * width + scx) * 4;
          var wt = weightsVector[cx];
          r += pixels[poffset] * wt;
          g += pixels[poffset + 1] * wt;
          b += pixels[poffset + 2] * wt;
          a += pixels[poffset + 3] * wt;
        }
        output[offset] = r;
        output[offset + 1] = g;
        output[offset + 2] = b;
        output[offset + 3] = a + alphaFac * (255 - a);
      }
    }
    return output;
  };

  /**
   * Fast vertical separable convolution. A point spread function (PSF) is
   * said to be separable if it can be broken into two one-dimensional
   * signals: a vertical and a horizontal projection. The convolution is
   * performed by sliding the kernel over the image, generally starting at the
   * top left corner, so as to move the kernel through all the positions where
   * the kernel fits entirely within the boundaries of the image. Adapted from
   * https://github.com/kig/canvasfilters.
   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.
   * @param {number} width The image width.
   * @param {number} height The image height.
   * @param {array} weightsVector The weighting vector, e.g [-1,0,1].
   * @param {number} opaque
   * @return {array} The convoluted pixels in a linear [r,g,b,a,...] array.
   */
  tracking.Image.verticalConvolve = function(pixels, width, height, weightsVector, opaque) {
    var side = weightsVector.length;
    var halfSide = Math.floor(side / 2);
    var output = new Float32Array(width * height * 4);
    var alphaFac = opaque ? 1 : 0;

    for (var y = 0; y < height; y++) {
      for (var x = 0; x < width; x++) {
        var sy = y;
        var sx = x;
        var offset = (y * width + x) * 4;
        var r = 0;
        var g = 0;
        var b = 0;
        var a = 0;
        for (var cy = 0; cy < side; cy++) {
          var scy = Math.min(height - 1, Math.max(0, sy + cy - halfSide));
          var scx = sx;
          var poffset = (scy * width + scx) * 4;
          var wt = weightsVector[cy];
          r += pixels[poffset] * wt;
          g += pixels[poffset + 1] * wt;
          b += pixels[poffset + 2] * wt;
          a += pixels[poffset + 3] * wt;
        }
        output[offset] = r;
        output[offset + 1] = g;
        output[offset + 2] = b;
        output[offset + 3] = a + alphaFac * (255 - a);
      }
    }
    return output;
  };

  /**
   * Fast separable convolution. A point spread function (PSF) is said to be
   * separable if it can be broken into two one-dimensional signals: a
   * vertical and a horizontal projection. The convolution is performed by
   * sliding the kernel over the image, generally starting at the top left
   * corner, so as to move the kernel through all the positions where the
   * kernel fits entirely within the boundaries of the image. Adapted from
   * https://github.com/kig/canvasfilters.
   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.
   * @param {number} width The image width.
   * @param {number} height The image height.
   * @param {array} horizWeights The horizontal weighting vector, e.g [-1,0,1].
   * @param {array} vertWeights The vertical vector, e.g [-1,0,1].
   * @param {number} opaque
   * @return {array} The convoluted pixels in a linear [r,g,b,a,...] array.
   */
  tracking.Image.separableConvolve = function(pixels, width, height, horizWeights, vertWeights, opaque) {
    var vertical = this.verticalConvolve(pixels, width, height, vertWeights, opaque);
    return this.horizontalConvolve(vertical, width, height, horizWeights, opaque);
  };

  /**
   * Compute image edges using Sobel operator. Computes the vertical and
   * horizontal gradients of the image and combines the computed images to
   * find edges in the image. The way we implement the Sobel filter here is by
   * first grayscaling the image, then taking the horizontal and vertical
   * gradients and finally combining the gradient images to make up the final
   * image. Adapted from https://github.com/kig/canvasfilters.
   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.
   * @param {number} width The image width.
   * @param {number} height The image height.
   * @return {array} The edge pixels in a linear [r,g,b,a,...] array.
   */
  tracking.Image.sobel = function(pixels, width, height) {
    pixels = this.grayscale(pixels, width, height, true);
    var output = new Float32Array(width * height * 4);
    var sobelSignVector = new Float32Array([-1, 0, 1]);
    var sobelScaleVector = new Float32Array([1, 2, 1]);
    var vertical = this.separableConvolve(pixels, width, height, sobelSignVector, sobelScaleVector);
    var horizontal = this.separableConvolve(pixels, width, height, sobelScaleVector, sobelSignVector);

    for (var i = 0; i < output.length; i += 4) {
      var v = vertical[i];
      var h = horizontal[i];
      var p = Math.sqrt(h * h + v * v);
      output[i] = p;
      output[i + 1] = p;
      output[i + 2] = p;
      output[i + 3] = 255;
    }

    return output;
  };

}());

(function() {
  /**
   * ViolaJones utility.
   * @static
   * @constructor
   */
  tracking.ViolaJones = {};

  /**
   * Holds the minimum area of intersection that defines when a rectangle is
   * from the same group. Often when a face is matched multiple rectangles are
   * classified as possible rectangles to represent the face, when they
   * intersects they are grouped as one face.
   * @type {number}
   * @default 0.5
   * @static
   */
  tracking.ViolaJones.REGIONS_OVERLAP = 0.5;

  /**
   * Holds the HAAR cascade classifiers converted from OpenCV training.
   * @type {array}
   * @static
   */
  tracking.ViolaJones.classifiers = {};

  /**
   * Detects through the HAAR cascade data rectangles matches.
   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.
   * @param {number} width The image width.
   * @param {number} height The image height.
   * @param {number} initialScale The initial scale to start the block
   *     scaling.
   * @param {number} scaleFactor The scale factor to scale the feature block.
   * @param {number} stepSize The block step size.
   * @param {number} edgesDensity Percentage density edges inside the
   *     classifier block. Value from [0.0, 1.0], defaults to 0.2. If specified
   *     edge detection will be applied to the image to prune dead areas of the
   *     image, this can improve significantly performance.
   * @param {number} data The HAAR cascade data.
   * @return {array} Found rectangles.
   * @static
   */
  tracking.ViolaJones.detect = function(pixels, width, height, initialScale, scaleFactor, stepSize, edgesDensity, data) {
    var total = 0;
    var rects = [];
    var integralImage = new Int32Array(width * height);
    var integralImageSquare = new Int32Array(width * height);
    var tiltedIntegralImage = new Int32Array(width * height);

    var integralImageSobel;
    if (edgesDensity > 0) {
      integralImageSobel = new Int32Array(width * height);
    }

    tracking.Image.computeIntegralImage(pixels, width, height, integralImage, integralImageSquare, tiltedIntegralImage, integralImageSobel);

    var minWidth = data[0];
    var minHeight = data[1];
    var scale = initialScale * scaleFactor;
    var blockWidth = (scale * minWidth) | 0;
    var blockHeight = (scale * minHeight) | 0;

    while (blockWidth < width && blockHeight < height) {
      var step = (scale * stepSize + 0.5) | 0;
      for (var i = 0; i < (height - blockHeight); i += step) {
        for (var j = 0; j < (width - blockWidth); j += step) {

          if (edgesDensity > 0) {
            if (this.isTriviallyExcluded(edgesDensity, integralImageSobel, i, j, width, blockWidth, blockHeight)) {
              continue;
            }
          }

          if (this.evalStages_(data, integralImage, integralImageSquare, tiltedIntegralImage, i, j, width, blockWidth, blockHeight, scale)) {
            rects[total++] = {
              width: blockWidth,
              height: blockHeight,
              x: j,
              y: i
            };
          }
        }
      }

      scale *= scaleFactor;
      blockWidth = (scale * minWidth) | 0;
      blockHeight = (scale * minHeight) | 0;
    }
    return this.mergeRectangles_(rects);
  };

  /**
   * Fast check to test whether the edges density inside the block is greater
   * than a threshold, if true it tests the stages. This can improve
   * significantly performance.
   * @param {number} edgesDensity Percentage density edges inside the
   *     classifier block.
   * @param {array} integralImageSobel The integral image of a sobel image.
   * @param {number} i Vertical position of the pixel to be evaluated.
   * @param {number} j Horizontal position of the pixel to be evaluated.
   * @param {number} width The image width.
   * @return {boolean} True whether the block at position i,j can be skipped,
   *     false otherwise.
   * @static
   * @protected
   */
  tracking.ViolaJones.isTriviallyExcluded = function(edgesDensity, integralImageSobel, i, j, width, blockWidth, blockHeight) {
    var wbA = i * width + j;
    var wbB = wbA + blockWidth;
    var wbD = wbA + blockHeight * width;
    var wbC = wbD + blockWidth;
    var blockEdgesDensity = (integralImageSobel[wbA] - integralImageSobel[wbB] - integralImageSobel[wbD] + integralImageSobel[wbC]) / (blockWidth * blockHeight * 255);
    if (blockEdgesDensity < edgesDensity) {
      return true;
    }
    return false;
  };

  /**
   * Evaluates if the block size on i,j position is a valid HAAR cascade
   * stage.
   * @param {number} data The HAAR cascade data.
   * @param {number} i Vertical position of the pixel to be evaluated.
   * @param {number} j Horizontal position of the pixel to be evaluated.
   * @param {number} width The image width.
   * @param {number} blockSize The block size.
   * @param {number} scale The scale factor of the block size and its original
   *     size.
   * @param {number} inverseArea The inverse area of the block size.
   * @return {boolean} Whether the region passes all the stage tests.
   * @private
   * @static
   */
  tracking.ViolaJones.evalStages_ = function(data, integralImage, integralImageSquare, tiltedIntegralImage, i, j, width, blockWidth, blockHeight, scale) {
    var inverseArea = 1.0 / (blockWidth * blockHeight);
    var wbA = i * width + j;
    var wbB = wbA + blockWidth;
    var wbD = wbA + blockHeight * width;
    var wbC = wbD + blockWidth;
    var mean = (integralImage[wbA] - integralImage[wbB] - integralImage[wbD] + integralImage[wbC]) * inverseArea;
    var variance = (integralImageSquare[wbA] - integralImageSquare[wbB] - integralImageSquare[wbD] + integralImageSquare[wbC]) * inverseArea - mean * mean;

    var standardDeviation = 1;
    if (variance > 0) {
      standardDeviation = Math.sqrt(variance);
    }

    var length = data.length;

    for (var w = 2; w < length; ) {
      var stageSum = 0;
      var stageThreshold = data[w++];
      var nodeLength = data[w++];

      while (nodeLength--) {
        var rectsSum = 0;
        var tilted = data[w++];
        var rectsLength = data[w++];

        for (var r = 0; r < rectsLength; r++) {
          var rectLeft = (j + data[w++] * scale + 0.5) | 0;
          var rectTop = (i + data[w++] * scale + 0.5) | 0;
          var rectWidth = (data[w++] * scale + 0.5) | 0;
          var rectHeight = (data[w++] * scale + 0.5) | 0;
          var rectWeight = data[w++];

          var w1;
          var w2;
          var w3;
          var w4;
          if (tilted) {
            // RectSum(r) = RSAT(x-h+w, y+w+h-1) + RSAT(x, y-1) - RSAT(x-h, y+h-1) - RSAT(x+w, y+w-1)
            w1 = (rectLeft - rectHeight + rectWidth) + (rectTop + rectWidth + rectHeight - 1) * width;
            w2 = rectLeft + (rectTop - 1) * width;
            w3 = (rectLeft - rectHeight) + (rectTop + rectHeight - 1) * width;
            w4 = (rectLeft + rectWidth) + (rectTop + rectWidth - 1) * width;
            rectsSum += (tiltedIntegralImage[w1] + tiltedIntegralImage[w2] - tiltedIntegralImage[w3] - tiltedIntegralImage[w4]) * rectWeight;
          } else {
            // RectSum(r) = SAT(x-1, y-1) + SAT(x+w-1, y+h-1) - SAT(x-1, y+h-1) - SAT(x+w-1, y-1)
            w1 = rectTop * width + rectLeft;
            w2 = w1 + rectWidth;
            w3 = w1 + rectHeight * width;
            w4 = w3 + rectWidth;
            rectsSum += (integralImage[w1] - integralImage[w2] - integralImage[w3] + integralImage[w4]) * rectWeight;
            // TODO: Review the code below to analyze performance when using it instead.
            // w1 = (rectLeft - 1) + (rectTop - 1) * width;
            // w2 = (rectLeft + rectWidth - 1) + (rectTop + rectHeight - 1) * width;
            // w3 = (rectLeft - 1) + (rectTop + rectHeight - 1) * width;
            // w4 = (rectLeft + rectWidth - 1) + (rectTop - 1) * width;
            // rectsSum += (integralImage[w1] + integralImage[w2] - integralImage[w3] - integralImage[w4]) * rectWeight;
          }
        }

        var nodeThreshold = data[w++];
        var nodeLeft = data[w++];
        var nodeRight = data[w++];

        if (rectsSum * inverseArea < nodeThreshold * standardDeviation) {
          stageSum += nodeLeft;
        } else {
          stageSum += nodeRight;
        }
      }

      if (stageSum < stageThreshold) {
        return false;
      }
    }
    return true;
  };

  /**
   * Postprocess the detected sub-windows in order to combine overlapping
   * detections into a single detection.
   * @param {array} rects
   * @return {array}
   * @private
   * @static
   */
  tracking.ViolaJones.mergeRectangles_ = function(rects) {
    var disjointSet = new tracking.DisjointSet(rects.length);

    for (var i = 0; i < rects.length; i++) {
      var r1 = rects[i];
      for (var j = 0; j < rects.length; j++) {
        var r2 = rects[j];
        if (tracking.Math.intersectRect(r1.x, r1.y, r1.x + r1.width, r1.y + r1.height, r2.x, r2.y, r2.x + r2.width, r2.y + r2.height)) {
          var x1 = Math.max(r1.x, r2.x);
          var y1 = Math.max(r1.y, r2.y);
          var x2 = Math.min(r1.x + r1.width, r2.x + r2.width);
          var y2 = Math.min(r1.y + r1.height, r2.y + r2.height);
          var overlap = (x1 - x2) * (y1 - y2);
          var area1 = (r1.width * r1.height);
          var area2 = (r2.width * r2.height);

          if ((overlap / (area1 * (area1 / area2)) >= this.REGIONS_OVERLAP) &&
            (overlap / (area2 * (area1 / area2)) >= this.REGIONS_OVERLAP)) {
            disjointSet.union(i, j);
          }
        }
      }
    }

    var map = {};
    for (var k = 0; k < disjointSet.length; k++) {
      var rep = disjointSet.find(k);
      if (!map[rep]) {
        map[rep] = {
          total: 1,
          width: rects[k].width,
          height: rects[k].height,
          x: rects[k].x,
          y: rects[k].y
        };
        continue;
      }
      map[rep].total++;
      map[rep].width += rects[k].width;
      map[rep].height += rects[k].height;
      map[rep].x += rects[k].x;
      map[rep].y += rects[k].y;
    }

    var result = [];
    Object.keys(map).forEach(function(key) {
      var rect = map[key];
      result.push({
        total: rect.total,
        width: (rect.width / rect.total + 0.5) | 0,
        height: (rect.height / rect.total + 0.5) | 0,
        x: (rect.x / rect.total + 0.5) | 0,
        y: (rect.y / rect.total + 0.5) | 0
      });
    });

    return result;
  };

}());

(function() {
  /**
   * Brief intends for "Binary Robust Independent Elementary Features".This
   * method generates a binary string for each keypoint found by an extractor
   * method.
   * @static
   * @constructor
   */
  tracking.Brief = {};

  /**
   * The set of binary tests is defined by the nd (x,y)-location pairs
   * uniquely chosen during the initialization. Values could vary between N =
   * 128,256,512. N=128 yield good compromises between speed, storage
   * efficiency, and recognition rate.
   * @type {number}
   */
  tracking.Brief.N = 512;

  /**
   * Caches coordinates values of (x,y)-location pairs uniquely chosen during
   * the initialization.
   * @type {Object.<number, Int32Array>}
   * @private
   * @static
   */
  tracking.Brief.randomImageOffsets_ = {};

  /**
   * Caches delta values of (x,y)-location pairs uniquely chosen during
   * the initialization.
   * @type {Int32Array}
   * @private
   * @static
   */
  tracking.Brief.randomWindowOffsets_ = null;

  /**
   * Generates a binary string for each found keypoints extracted using an
   * extractor method.
   * @param {array} The grayscale pixels in a linear [p1,p2,...] array.
   * @param {number} width The image width.
   * @param {array} keypoints
   * @return {Int32Array} Returns an array where for each four sequence int
   *     values represent the descriptor binary string (128 bits) necessary
   *     to describe the corner, e.g. [0,0,0,0, 0,0,0,0, ...].
   * @static
   */
  tracking.Brief.getDescriptors = function(pixels, width, keypoints) {
    // Optimizing divide by 32 operation using binary shift
    // (this.N >> 5) === this.N/32.
    var descriptors = new Int32Array((keypoints.length >> 1) * (this.N >> 5));
    var descriptorWord = 0;
    var offsets = this.getRandomOffsets_(width);
    var position = 0;

    for (var i = 0; i < keypoints.length; i += 2) {
      var w = width * keypoints[i + 1] + keypoints[i];

      var offsetsPosition = 0;
      for (var j = 0, n = this.N; j < n; j++) {
        if (pixels[offsets[offsetsPosition++] + w] < pixels[offsets[offsetsPosition++] + w]) {
          // The bit in the position `j % 32` of descriptorWord should be set to 1. We do
          // this by making an OR operation with a binary number that only has the bit
          // in that position set to 1. That binary number is obtained by shifting 1 left by
          // `j % 32` (which is the same as `j & 31` left) positions.
          descriptorWord |= 1 << (j & 31);
        }

        // If the next j is a multiple of 32, we will need to use a new descriptor word to hold
        // the next results.
        if (!((j + 1) & 31)) {
          descriptors[position++] = descriptorWord;
          descriptorWord = 0;
        }
      }
    }

    return descriptors;
  };

  /**
   * Matches sets of features {mi} and {mj} extracted from two images taken
   * from similar, and often successive, viewpoints. A classical procedure
   * runs as follows. For each point {mi} in the first image, search in a
   * region of the second image around location {mi} for point {mj}. The
   * search is based on the similarity of the local image windows, also known
   * as kernel windows, centered on the points, which strongly characterizes
   * the points when the images are sufficiently close. Once each keypoint is
   * described with its binary string, they need to be compared with the
   * closest matching point. Distance metric is critical to the performance of
   * in- trusion detection systems. Thus using binary strings reduces the size
   * of the descriptor and provides an interesting data structure that is fast
   * to operate whose similarity can be measured by the Hamming distance.
   * @param {array} keypoints1
   * @param {array} descriptors1
   * @param {array} keypoints2
   * @param {array} descriptors2
   * @return {Int32Array} Returns an array where the index is the corner1
   *     index coordinate, and the value is the corresponding match index of
   *     corner2, e.g. keypoints1=[x0,y0,x1,y1,...] and
   *     keypoints2=[x'0,y'0,x'1,y'1,...], if x0 matches x'1 and x1 matches x'0,
   *     the return array would be [3,0].
   * @static
   */
  tracking.Brief.match = function(keypoints1, descriptors1, keypoints2, descriptors2) {
    var len1 = keypoints1.length >> 1;
    var len2 = keypoints2.length >> 1;
    var matches = new Array(len1);

    for (var i = 0; i < len1; i++) {
      var min = Infinity;
      var minj = 0;
      for (var j = 0; j < len2; j++) {
        var dist = 0;
        // Optimizing divide by 32 operation using binary shift
        // (this.N >> 5) === this.N/32.
        for (var k = 0, n = this.N >> 5; k < n; k++) {
          dist += tracking.Math.hammingWeight(descriptors1[i * n + k] ^ descriptors2[j * n + k]);
        }
        if (dist < min) {
          min = dist;
          minj = j;
        }
      }
      matches[i] = {
        index1: i,
        index2: minj,
        keypoint1: [keypoints1[2 * i], keypoints1[2 * i + 1]],
        keypoint2: [keypoints2[2 * minj], keypoints2[2 * minj + 1]],
        confidence: 1 - min / this.N
      };
    }

    return matches;
  };

  /**
   * Removes matches outliers by testing matches on both directions.
   * @param {array} keypoints1
   * @param {array} descriptors1
   * @param {array} keypoints2
   * @param {array} descriptors2
   * @return {Int32Array} Returns an array where the index is the corner1
   *     index coordinate, and the value is the corresponding match index of
   *     corner2, e.g. keypoints1=[x0,y0,x1,y1,...] and
   *     keypoints2=[x'0,y'0,x'1,y'1,...], if x0 matches x'1 and x1 matches x'0,
   *     the return array would be [3,0].
   * @static
   */
  tracking.Brief.reciprocalMatch = function(keypoints1, descriptors1, keypoints2, descriptors2) {
    var matches = [];
    if (keypoints1.length === 0 || keypoints2.length === 0) {
      return matches;
    }

    var matches1 = tracking.Brief.match(keypoints1, descriptors1, keypoints2, descriptors2);
    var matches2 = tracking.Brief.match(keypoints2, descriptors2, keypoints1, descriptors1);
    for (var i = 0; i < matches1.length; i++) {
      if (matches2[matches1[i].index2].index2 === i) {
        matches.push(matches1[i]);
      }
    }
    return matches;
  };

  /**
   * Gets the coordinates values of (x,y)-location pairs uniquely chosen
   * during the initialization.
   * @return {array} Array with the random offset values.
   * @private
   */
  tracking.Brief.getRandomOffsets_ = function(width) {
    if (!this.randomWindowOffsets_) {
      var windowPosition = 0;
      var windowOffsets = new Int32Array(4 * this.N);
      for (var i = 0; i < this.N; i++) {
        windowOffsets[windowPosition++] = Math.round(tracking.Math.uniformRandom(-15, 16));
        windowOffsets[windowPosition++] = Math.round(tracking.Math.uniformRandom(-15, 16));
        windowOffsets[windowPosition++] = Math.round(tracking.Math.uniformRandom(-15, 16));
        windowOffsets[windowPosition++] = Math.round(tracking.Math.uniformRandom(-15, 16));
      }
      this.randomWindowOffsets_ = windowOffsets;
    }

    if (!this.randomImageOffsets_[width]) {
      var imagePosition = 0;
      var imageOffsets = new Int32Array(2 * this.N);
      for (var j = 0; j < this.N; j++) {
        imageOffsets[imagePosition++] = this.randomWindowOffsets_[4 * j] * width + this.randomWindowOffsets_[4 * j + 1];
        imageOffsets[imagePosition++] = this.randomWindowOffsets_[4 * j + 2] * width + this.randomWindowOffsets_[4 * j + 3];
      }
      this.randomImageOffsets_[width] = imageOffsets;
    }

    return this.randomImageOffsets_[width];
  };
}());

(function() {
  /**
   * FAST intends for "Features from Accelerated Segment Test". This method
   * performs a point segment test corner detection. The segment test
   * criterion operates by considering a circle of sixteen pixels around the
   * corner candidate p. The detector classifies p as a corner if there exists
   * a set of n contiguous pixelsin the circle which are all brighter than the
   * intensity of the candidate pixel Ip plus a threshold t, or all darker
   * than Ip  t.
   *
   *       15 00 01
   *    14          02
   * 13                03
   * 12       []       04
   * 11                05
   *    10          06
   *       09 08 07
   *
   * For more reference:
   * http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.60.3991&rep=rep1&type=pdf
   * @static
   * @constructor
   */
  tracking.Fast = {};

  /**
   * Holds the threshold to determine whether the tested pixel is brighter or
   * darker than the corner candidate p.
   * @type {number}
   * @default 40
   * @static
   */
  tracking.Fast.THRESHOLD = 40;

  /**
   * Caches coordinates values of the circle surrounding the pixel candidate p.
   * @type {Object.<number, Int32Array>}
   * @private
   * @static
   */
  tracking.Fast.circles_ = {};

  /**
   * Finds corners coordinates on the graysacaled image.
   * @param {array} The grayscale pixels in a linear [p1,p2,...] array.
   * @param {number} width The image width.
   * @param {number} height The image height.
   * @param {number} threshold to determine whether the tested pixel is brighter or
   *     darker than the corner candidate p. Default value is 40.
   * @return {array} Array containing the coordinates of all found corners,
   *     e.g. [x0,y0,x1,y1,...], where P(x0,y0) represents a corner coordinate.
   * @static
   */
  tracking.Fast.findCorners = function(pixels, width, height, opt_threshold) {
    var circleOffsets = this.getCircleOffsets_(width);
    var circlePixels = new Int32Array(16);
    var corners = [];

    if (opt_threshold === undefined) {
      opt_threshold = this.THRESHOLD;
    }

    // When looping through the image pixels, skips the first three lines from
    // the image boundaries to constrain the surrounding circle inside the image
    // area.
    for (var i = 3; i < height - 3; i++) {
      for (var j = 3; j < width - 3; j++) {
        var w = i * width + j;
        var p = pixels[w];

        // Loops the circle offsets to read the pixel value for the sixteen
        // surrounding pixels.
        for (var k = 0; k < 16; k++) {
          circlePixels[k] = pixels[w + circleOffsets[k]];
        }

        if (this.isCorner(p, circlePixels, opt_threshold)) {
          // The pixel p is classified as a corner, as optimization increment j
          // by the circle radius 3 to skip the neighbor pixels inside the
          // surrounding circle. This can be removed without compromising the
          // result.
          corners.push(j, i);
          j += 3;
        }
      }
    }

    return corners;
  };

  /**
   * Checks if the circle pixel is brighter than the candidate pixel p by
   * a threshold.
   * @param {number} circlePixel The circle pixel value.
   * @param {number} p The value of the candidate pixel p.
   * @param {number} threshold
   * @return {Boolean}
   * @static
   */
  tracking.Fast.isBrighter = function(circlePixel, p, threshold) {
    return circlePixel - p > threshold;
  };

  /**
   * Checks if the circle pixel is within the corner of the candidate pixel p
   * by a threshold.
   * @param {number} p The value of the candidate pixel p.
   * @param {number} circlePixel The circle pixel value.
   * @param {number} threshold
   * @return {Boolean}
   * @static
   */
  tracking.Fast.isCorner = function(p, circlePixels, threshold) {
    if (this.isTriviallyExcluded(circlePixels, p, threshold)) {
      return false;
    }

    for (var x = 0; x < 16; x++) {
      var darker = true;
      var brighter = true;

      for (var y = 0; y < 9; y++) {
        var circlePixel = circlePixels[(x + y) & 15];

        if (!this.isBrighter(p, circlePixel, threshold)) {
          brighter = false;
          if (darker === false) {
            break;
          }
        }

        if (!this.isDarker(p, circlePixel, threshold)) {
          darker = false;
          if (brighter === false) {
            break;
          }
        }
      }

      if (brighter || darker) {
        return true;
      }
    }

    return false;
  };

  /**
   * Checks if the circle pixel is darker than the candidate pixel p by
   * a threshold.
   * @param {number} circlePixel The circle pixel value.
   * @param {number} p The value of the candidate pixel p.
   * @param {number} threshold
   * @return {Boolean}
   * @static
   */
  tracking.Fast.isDarker = function(circlePixel, p, threshold) {
    return p - circlePixel > threshold;
  };

  /**
   * Fast check to test if the candidate pixel is a trivially excluded value.
   * In order to be a corner, the candidate pixel value should be darker or
   * brighter than 9-12 surrounding pixels, when at least three of the top,
   * bottom, left and right pixels are brighter or darker it can be
   * automatically excluded improving the performance.
   * @param {number} circlePixel The circle pixel value.
   * @param {number} p The value of the candidate pixel p.
   * @param {number} threshold
   * @return {Boolean}
   * @static
   * @protected
   */
  tracking.Fast.isTriviallyExcluded = function(circlePixels, p, threshold) {
    var count = 0;
    var circleBottom = circlePixels[8];
    var circleLeft = circlePixels[12];
    var circleRight = circlePixels[4];
    var circleTop = circlePixels[0];

    if (this.isBrighter(circleTop, p, threshold)) {
      count++;
    }
    if (this.isBrighter(circleRight, p, threshold)) {
      count++;
    }
    if (this.isBrighter(circleBottom, p, threshold)) {
      count++;
    }
    if (this.isBrighter(circleLeft, p, threshold)) {
      count++;
    }

    if (count < 3) {
      count = 0;
      if (this.isDarker(circleTop, p, threshold)) {
        count++;
      }
      if (this.isDarker(circleRight, p, threshold)) {
        count++;
      }
      if (this.isDarker(circleBottom, p, threshold)) {
        count++;
      }
      if (this.isDarker(circleLeft, p, threshold)) {
        count++;
      }
      if (count < 3) {
        return true;
      }
    }

    return false;
  };

  /**
   * Gets the sixteen offset values of the circle surrounding pixel.
   * @param {number} width The image width.
   * @return {array} Array with the sixteen offset values of the circle
   *     surrounding pixel.
   * @private
   */
  tracking.Fast.getCircleOffsets_ = function(width) {
    if (this.circles_[width]) {
      return this.circles_[width];
    }

    var circle = new Int32Array(16);

    circle[0] = -width - width - width;
    circle[1] = circle[0] + 1;
    circle[2] = circle[1] + width + 1;
    circle[3] = circle[2] + width + 1;
    circle[4] = circle[3] + width;
    circle[5] = circle[4] + width;
    circle[6] = circle[5] + width - 1;
    circle[7] = circle[6] + width - 1;
    circle[8] = circle[7] - 1;
    circle[9] = circle[8] - 1;
    circle[10] = circle[9] - width - 1;
    circle[11] = circle[10] - width - 1;
    circle[12] = circle[11] - width;
    circle[13] = circle[12] - width;
    circle[14] = circle[13] - width + 1;
    circle[15] = circle[14] - width + 1;

    this.circles_[width] = circle;
    return circle;
  };
}());

(function() {
  /**
   * Math utility.
   * @static
   * @constructor
   */
  tracking.Math = {};

  /**
   * Euclidean distance between two points P(x0, y0) and P(x1, y1).
   * @param {number} x0 Horizontal coordinate of P0.
   * @param {number} y0 Vertical coordinate of P0.
   * @param {number} x1 Horizontal coordinate of P1.
   * @param {number} y1 Vertical coordinate of P1.
   * @return {number} The euclidean distance.
   */
  tracking.Math.distance = function(x0, y0, x1, y1) {
    var dx = x1 - x0;
    var dy = y1 - y0;

    return Math.sqrt(dx * dx + dy * dy);
  };

  /**
   * Calculates the Hamming weight of a string, which is the number of symbols that are
   * different from the zero-symbol of the alphabet used. It is thus
   * equivalent to the Hamming distance from the all-zero string of the same
   * length. For the most typical case, a string of bits, this is the number
   * of 1's in the string.
   *
   * Example:
   *
   * <pre>
   *  Binary string     Hamming weight
   *   11101                 4
   *   11101010              5
   * </pre>
   *
   * @param {number} i Number that holds the binary string to extract the hamming weight.
   * @return {number} The hamming weight.
   */
  tracking.Math.hammingWeight = function(i) {
    i = i - ((i >> 1) & 0x55555555);
    i = (i & 0x33333333) + ((i >> 2) & 0x33333333);

    return ((i + (i >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;
  };

  /**
   * Generates a random number between [a, b] interval.
   * @param {number} a
   * @param {number} b
   * @return {number}
   */
  tracking.Math.uniformRandom = function(a, b) {
    return a + Math.random() * (b - a);
  };

  /**
   * Tests if a rectangle intersects with another.
   *
   *  <pre>
   *  x0y0 --------       x2y2 --------
   *      |       |           |       |
   *      -------- x1y1       -------- x3y3
   * </pre>
   *
   * @param {number} x0 Horizontal coordinate of P0.
   * @param {number} y0 Vertical coordinate of P0.
   * @param {number} x1 Horizontal coordinate of P1.
   * @param {number} y1 Vertical coordinate of P1.
   * @param {number} x2 Horizontal coordinate of P2.
   * @param {number} y2 Vertical coordinate of P2.
   * @param {number} x3 Horizontal coordinate of P3.
   * @param {number} y3 Vertical coordinate of P3.
   * @return {boolean}
   */
  tracking.Math.intersectRect = function(x0, y0, x1, y1, x2, y2, x3, y3) {
    return !(x2 > x1 || x3 < x0 || y2 > y1 || y3 < y0);
  };

}());

(function() {
  /**
   * Matrix utility.
   * @static
   * @constructor
   */
  tracking.Matrix = {};

  /**
   * Loops the array organized as major-row order and executes `fn` callback
   * for each iteration. The `fn` callback receives the following parameters:
   * `(r,g,b,a,index,i,j)`, where `r,g,b,a` represents the pixel color with
   * alpha channel, `index` represents the position in the major-row order
   * array and `i,j` the respective indexes positions in two dimensions.
   * @param {array} pixels The pixels in a linear [r,g,b,a,...] array to loop
   *     through.
   * @param {number} width The image width.
   * @param {number} height The image height.
   * @param {function} fn The callback function for each pixel.
   * @param {number} opt_jump Optional jump for the iteration, by default it
   *     is 1, hence loops all the pixels of the array.
   * @static
   */
  tracking.Matrix.forEach = function(pixels, width, height, fn, opt_jump) {
    opt_jump = opt_jump || 1;
    for (var i = 0; i < height; i += opt_jump) {
      for (var j = 0; j < width; j += opt_jump) {
        var w = i * width * 4 + j * 4;
        fn.call(this, pixels[w], pixels[w + 1], pixels[w + 2], pixels[w + 3], w, i, j);
      }
    }
  };

}());

(function() {
  /**
   * EPnp utility.
   * @static
   * @constructor
   */
  tracking.EPnP = {};

  tracking.EPnP.solve = function(objectPoints, imagePoints, cameraMatrix) {};
}());

(function() {
  /**
   * Tracker utility.
   * @constructor
   * @extends {tracking.EventEmitter}
   */
  tracking.Tracker = function() {
    tracking.Tracker.base(this, 'constructor');
  };

  tracking.inherits(tracking.Tracker, tracking.EventEmitter);

  /**
   * Tracks the pixels on the array. This method is called for each video
   * frame in order to emit `track` event.
   * @param {Uint8ClampedArray} pixels The pixels data to track.
   * @param {number} width The pixels canvas width.
   * @param {number} height The pixels canvas height.
   */
  tracking.Tracker.prototype.track = function() {};
}());

(function() {
  /**
   * TrackerTask utility.
   * @constructor
   * @extends {tracking.EventEmitter}
   */
  tracking.TrackerTask = function(tracker) {
    tracking.TrackerTask.base(this, 'constructor');

    if (!tracker) {
      throw new Error('Tracker instance not specified.');
    }

    this.setTracker(tracker);
  };

  tracking.inherits(tracking.TrackerTask, tracking.EventEmitter);

  /**
   * Holds the tracker instance managed by this task.
   * @type {tracking.Tracker}
   * @private
   */
  tracking.TrackerTask.prototype.tracker_ = null;

  /**
   * Holds if the tracker task is in running.
   * @type {boolean}
   * @private
   */
  tracking.TrackerTask.prototype.running_ = false;

  /**
   * Gets the tracker instance managed by this task.
   * @return {tracking.Tracker}
   */
  tracking.TrackerTask.prototype.getTracker = function() {
    return this.tracker_;
  };

  /**
   * Returns true if the tracker task is in running, false otherwise.
   * @return {boolean}
   * @private
   */
  tracking.TrackerTask.prototype.inRunning = function() {
    return this.running_;
  };

  /**
   * Sets if the tracker task is in running.
   * @param {boolean} running
   * @private
   */
  tracking.TrackerTask.prototype.setRunning = function(running) {
    this.running_ = running;
  };

  /**
   * Sets the tracker instance managed by this task.
   * @return {tracking.Tracker}
   */
  tracking.TrackerTask.prototype.setTracker = function(tracker) {
    this.tracker_ = tracker;
  };

  /**
   * Emits a `run` event on the tracker task for the implementers to run any
   * child action, e.g. `requestAnimationFrame`.
   * @return {object} Returns itself, so calls can be chained.
   */
  tracking.TrackerTask.prototype.run = function() {
    var self = this;

    if (this.inRunning()) {
      return;
    }

    this.setRunning(true);
    this.reemitTrackEvent_ = function(event) {
      self.emit('track', event);
    };
    this.tracker_.on('track', this.reemitTrackEvent_);
    this.emit('run');
    return this;
  };

  /**
   * Emits a `stop` event on the tracker task for the implementers to stop any
   * child action being done, e.g. `requestAnimationFrame`.
   * @return {object} Returns itself, so calls can be chained.
   */
  tracking.TrackerTask.prototype.stop = function() {
    if (!this.inRunning()) {
      return;
    }

    this.setRunning(false);
    this.emit('stop');
    this.tracker_.removeListener('track', this.reemitTrackEvent_);
    return this;
  };
}());

(function() {
  /**
   * ColorTracker utility to track colored blobs in a frame using color
   * difference evaluation.
   * @constructor
   * @param {string|Array.<string>} opt_colors Optional colors to track.
   * @extends {tracking.Tracker}
   */
  tracking.ColorTracker = function(opt_colors) {
    tracking.ColorTracker.base(this, 'constructor');

    if (typeof opt_colors === 'string') {
      opt_colors = [opt_colors];
    }

    if (opt_colors) {
      opt_colors.forEach(function(color) {
        if (!tracking.ColorTracker.getColor(color)) {
          throw new Error('Color not valid, try `new tracking.ColorTracker("magenta")`.');
        }
      });
      this.setColors(opt_colors);
    }
  };

  tracking.inherits(tracking.ColorTracker, tracking.Tracker);

  /**
   * Holds the known colors.
   * @type {Object.<string, function>}
   * @private
   * @static
   */
  tracking.ColorTracker.knownColors_ = {};

  /**
   * Caches coordinates values of the neighbours surrounding a pixel.
   * @type {Object.<number, Int32Array>}
   * @private
   * @static
   */
  tracking.ColorTracker.neighbours_ = {};

  /**
   * Registers a color as known color.
   * @param {string} name The color name.
   * @param {function} fn The color function to test if the passed (r,g,b) is
   *     the desired color.
   * @static
   */
  tracking.ColorTracker.registerColor = function(name, fn) {
    tracking.ColorTracker.knownColors_[name] = fn;
  };

  /**
   * Gets the known color function that is able to test whether an (r,g,b) is
   * the desired color.
   * @param {string} name The color name.
   * @return {function} The known color test function.
   * @static
   */
  tracking.ColorTracker.getColor = function(name) {
    return tracking.ColorTracker.knownColors_[name];
  };

  /**
   * Holds the colors to be tracked by the `ColorTracker` instance.
   * @default ['magenta']
   * @type {Array.<string>}
   */
  tracking.ColorTracker.prototype.colors = ['magenta'];

  /**
   * Holds the minimum dimension to classify a rectangle.
   * @default 20
   * @type {number}
   */
  tracking.ColorTracker.prototype.minDimension = 20;

  /**
   * Holds the maximum dimension to classify a rectangle.
   * @default Infinity
   * @type {number}
   */
  tracking.ColorTracker.prototype.maxDimension = Infinity;


  /**
   * Holds the minimum group size to be classified as a rectangle.
   * @default 30
   * @type {number}
   */
  tracking.ColorTracker.prototype.minGroupSize = 30;

  /**
   * Calculates the central coordinate from the cloud points. The cloud points
   * are all points that matches the desired color.
   * @param {Array.<number>} cloud Major row order array containing all the
   *     points from the desired color, e.g. [x1, y1, c2, y2, ...].
   * @param {number} total Total numbers of pixels of the desired color.
   * @return {object} Object containing the x, y and estimated z coordinate of
   *     the blog extracted from the cloud points.
   * @private
   */
  tracking.ColorTracker.prototype.calculateDimensions_ = function(cloud, total) {
    var maxx = -1;
    var maxy = -1;
    var minx = Infinity;
    var miny = Infinity;

    for (var c = 0; c < total; c += 2) {
      var x = cloud[c];
      var y = cloud[c + 1];

      if (x < minx) {
        minx = x;
      }
      if (x > maxx) {
        maxx = x;
      }
      if (y < miny) {
        miny = y;
      }
      if (y > maxy) {
        maxy = y;
      }
    }

    return {
      width: maxx - minx,
      height: maxy - miny,
      x: minx,
      y: miny
    };
  };

  /**
   * Gets the colors being tracked by the `ColorTracker` instance.
   * @return {Array.<string>}
   */
  tracking.ColorTracker.prototype.getColors = function() {
    return this.colors;
  };

  /**
   * Gets the minimum dimension to classify a rectangle.
   * @return {number}
   */
  tracking.ColorTracker.prototype.getMinDimension = function() {
    return this.minDimension;
  };

  /**
   * Gets the maximum dimension to classify a rectangle.
   * @return {number}
   */
  tracking.ColorTracker.prototype.getMaxDimension = function() {
    return this.maxDimension;
  };

  /**
   * Gets the minimum group size to be classified as a rectangle.
   * @return {number}
   */
  tracking.ColorTracker.prototype.getMinGroupSize = function() {
    return this.minGroupSize;
  };

  /**
   * Gets the eight offset values of the neighbours surrounding a pixel.
   * @param {number} width The image width.
   * @return {array} Array with the eight offset values of the neighbours
   *     surrounding a pixel.
   * @private
   */
  tracking.ColorTracker.prototype.getNeighboursForWidth_ = function(width) {
    if (tracking.ColorTracker.neighbours_[width]) {
      return tracking.ColorTracker.neighbours_[width];
    }

    var neighbours = new Int32Array(8);

    neighbours[0] = -width * 4;
    neighbours[1] = -width * 4 + 4;
    neighbours[2] = 4;
    neighbours[3] = width * 4 + 4;
    neighbours[4] = width * 4;
    neighbours[5] = width * 4 - 4;
    neighbours[6] = -4;
    neighbours[7] = -width * 4 - 4;

    tracking.ColorTracker.neighbours_[width] = neighbours;

    return neighbours;
  };

  /**
   * Unites groups whose bounding box intersect with each other.
   * @param {Array.<Object>} rects
   * @private
   */
  tracking.ColorTracker.prototype.mergeRectangles_ = function(rects) {
    var intersects;
    var results = [];
    var minDimension = this.getMinDimension();
    var maxDimension = this.getMaxDimension();

    for (var r = 0; r < rects.length; r++) {
      var r1 = rects[r];
      intersects = true;
      for (var s = r + 1; s < rects.length; s++) {
        var r2 = rects[s];
        if (tracking.Math.intersectRect(r1.x, r1.y, r1.x + r1.width, r1.y + r1.height, r2.x, r2.y, r2.x + r2.width, r2.y + r2.height)) {
          intersects = false;
          var x1 = Math.min(r1.x, r2.x);
          var y1 = Math.min(r1.y, r2.y);
          var x2 = Math.max(r1.x + r1.width, r2.x + r2.width);
          var y2 = Math.max(r1.y + r1.height, r2.y + r2.height);
          r2.height = y2 - y1;
          r2.width = x2 - x1;
          r2.x = x1;
          r2.y = y1;
          break;
        }
      }

      if (intersects) {
        if (r1.width >= minDimension && r1.height >= minDimension) {
          if (r1.width <= maxDimension && r1.height <= maxDimension) {
            results.push(r1);
          }
        }
      }
    }

    return results;
  };

  /**
   * Sets the colors to be tracked by the `ColorTracker` instance.
   * @param {Array.<string>} colors
   */
  tracking.ColorTracker.prototype.setColors = function(colors) {
    this.colors = colors;
  };

  /**
   * Sets the minimum dimension to classify a rectangle.
   * @param {number} minDimension
   */
  tracking.ColorTracker.prototype.setMinDimension = function(minDimension) {
    this.minDimension = minDimension;
  };

  /**
   * Sets the maximum dimension to classify a rectangle.
   * @param {number} maxDimension
   */
  tracking.ColorTracker.prototype.setMaxDimension = function(maxDimension) {
    this.maxDimension = maxDimension;
  };

  /**
   * Sets the minimum group size to be classified as a rectangle.
   * @param {number} minGroupSize
   */
  tracking.ColorTracker.prototype.setMinGroupSize = function(minGroupSize) {
    this.minGroupSize = minGroupSize;
  };

  /**
   * Tracks the `Video` frames. This method is called for each video frame in
   * order to emit `track` event.
   * @param {Uint8ClampedArray} pixels The pixels data to track.
   * @param {number} width The pixels canvas width.
   * @param {number} height The pixels canvas height.
   */
  tracking.ColorTracker.prototype.track = function(pixels, width, height) {
    var self = this;
    var colors = this.getColors();

    if (!colors) {
      throw new Error('Colors not specified, try `new tracking.ColorTracker("magenta")`.');
    }

    var results = [];

    colors.forEach(function(color) {
      results = results.concat(self.trackColor_(pixels, width, height, color));
    });

    this.emit('track', {
      data: results
    });
  };

  /**
   * Find the given color in the given matrix of pixels using Flood fill
   * algorithm to determines the area connected to a given node in a
   * multi-dimensional array.
   * @param {Uint8ClampedArray} pixels The pixels data to track.
   * @param {number} width The pixels canvas width.
   * @param {number} height The pixels canvas height.
   * @param {string} color The color to be found
   * @private
   */
  tracking.ColorTracker.prototype.trackColor_ = function(pixels, width, height, color) {
    var colorFn = tracking.ColorTracker.knownColors_[color];
    var currGroup = new Int32Array(pixels.length >> 2);
    var currGroupSize;
    var currI;
    var currJ;
    var currW;
    var marked = new Int8Array(pixels.length);
    var minGroupSize = this.getMinGroupSize();
    var neighboursW = this.getNeighboursForWidth_(width);
    var queue = new Int32Array(pixels.length);
    var queuePosition;
    var results = [];
    var w = -4;

    if (!colorFn) {
      return results;
    }

    for (var i = 0; i < height; i++) {
      for (var j = 0; j < width; j++) {
        w += 4;

        if (marked[w]) {
          continue;
        }

        currGroupSize = 0;

        queuePosition = -1;
        queue[++queuePosition] = w;
        queue[++queuePosition] = i;
        queue[++queuePosition] = j;

        marked[w] = 1;

        while (queuePosition >= 0) {
          currJ = queue[queuePosition--];
          currI = queue[queuePosition--];
          currW = queue[queuePosition--];

          if (colorFn(pixels[currW], pixels[currW + 1], pixels[currW + 2], pixels[currW + 3], currW, currI, currJ)) {
            currGroup[currGroupSize++] = currJ;
            currGroup[currGroupSize++] = currI;

            for (var k = 0; k < neighboursW.length; k++) {
              var otherW = currW + neighboursW[k];
              var otherI = currI + neighboursI[k];
              var otherJ = currJ + neighboursJ[k];
              if (!marked[otherW] && otherI >= 0 && otherI < height && otherJ >= 0 && otherJ < width) {
                queue[++queuePosition] = otherW;
                queue[++queuePosition] = otherI;
                queue[++queuePosition] = otherJ;

                marked[otherW] = 1;
              }
            }
          }
        }

        if (currGroupSize >= minGroupSize) {
          var data = this.calculateDimensions_(currGroup, currGroupSize);
          if (data) {
            data.color = color;
            results.push(data);
          }
        }
      }
    }

    return this.mergeRectangles_(results);
  };

  // Default colors
  //===================

  tracking.ColorTracker.registerColor('cyan', function(r, g, b) {
    var thresholdGreen = 50,
      thresholdBlue = 70,
      dx = r - 0,
      dy = g - 255,
      dz = b - 255;

    if ((g - r) >= thresholdGreen && (b - r) >= thresholdBlue) {
      return true;
    }
    return dx * dx + dy * dy + dz * dz < 6400;
  });

  tracking.ColorTracker.registerColor('magenta', function(r, g, b) {
    var threshold = 50,
      dx = r - 255,
      dy = g - 0,
      dz = b - 255;

    if ((r - g) >= threshold && (b - g) >= threshold) {
      return true;
    }
    return dx * dx + dy * dy + dz * dz < 19600;
  });

  tracking.ColorTracker.registerColor('yellow', function(r, g, b) {
    var threshold = 50,
      dx = r - 255,
      dy = g - 255,
      dz = b - 0;

    if ((r - b) >= threshold && (g - b) >= threshold) {
      return true;
    }
    return dx * dx + dy * dy + dz * dz < 10000;
  });


  // Caching neighbour i/j offset values.
  //=====================================
  var neighboursI = new Int32Array([-1, -1, 0, 1, 1, 1, 0, -1]);
  var neighboursJ = new Int32Array([0, 1, 1, 1, 0, -1, -1, -1]);
}());

(function() {
  /**
   * ObjectTracker utility.
   * @constructor
   * @param {string|Array.<string|Array.<number>>} opt_classifiers Optional
   *     object classifiers to track.
   * @extends {tracking.Tracker}
   */
  tracking.ObjectTracker = function(opt_classifiers) {
    tracking.ObjectTracker.base(this, 'constructor');

    if (opt_classifiers) {
      if (!Array.isArray(opt_classifiers)) {
        opt_classifiers = [opt_classifiers];
      }

      if (Array.isArray(opt_classifiers)) {
        opt_classifiers.forEach(function(classifier, i) {
          if (typeof classifier === 'string') {
            opt_classifiers[i] = tracking.ViolaJones.classifiers[classifier];
          }
          if (!opt_classifiers[i]) {
            throw new Error('Object classifier not valid, try `new tracking.ObjectTracker("face")`.');
          }
        });
      }
    }

    this.setClassifiers(opt_classifiers);
  };

  tracking.inherits(tracking.ObjectTracker, tracking.Tracker);

  /**
   * Specifies the edges density of a block in order to decide whether to skip
   * it or not.
   * @default 0.2
   * @type {number}
   */
  tracking.ObjectTracker.prototype.edgesDensity = 0.2;

  /**
   * Specifies the initial scale to start the feature block scaling.
   * @default 1.0
   * @type {number}
   */
  tracking.ObjectTracker.prototype.initialScale = 1.0;

  /**
   * Specifies the scale factor to scale the feature block.
   * @default 1.25
   * @type {number}
   */
  tracking.ObjectTracker.prototype.scaleFactor = 1.25;

  /**
   * Specifies the block step size.
   * @default 1.5
   * @type {number}
   */
  tracking.ObjectTracker.prototype.stepSize = 1.5;

  /**
   * Gets the tracker HAAR classifiers.
   * @return {TypedArray.<number>}
   */
  tracking.ObjectTracker.prototype.getClassifiers = function() {
    return this.classifiers;
  };

  /**
   * Gets the edges density value.
   * @return {number}
   */
  tracking.ObjectTracker.prototype.getEdgesDensity = function() {
    return this.edgesDensity;
  };

  /**
   * Gets the initial scale to start the feature block scaling.
   * @return {number}
   */
  tracking.ObjectTracker.prototype.getInitialScale = function() {
    return this.initialScale;
  };

  /**
   * Gets the scale factor to scale the feature block.
   * @return {number}
   */
  tracking.ObjectTracker.prototype.getScaleFactor = function() {
    return this.scaleFactor;
  };

  /**
   * Gets the block step size.
   * @return {number}
   */
  tracking.ObjectTracker.prototype.getStepSize = function() {
    return this.stepSize;
  };

  /**
   * Tracks the `Video` frames. This method is called for each video frame in
   * order to emit `track` event.
   * @param {Uint8ClampedArray} pixels The pixels data to track.
   * @param {number} width The pixels canvas width.
   * @param {number} height The pixels canvas height.
   */
  tracking.ObjectTracker.prototype.track = function(pixels, width, height) {
    var self = this;
    var classifiers = this.getClassifiers();

    if (!classifiers) {
      throw new Error('Object classifier not specified, try `new tracking.ObjectTracker("face")`.');
    }

    var results = [];

    classifiers.forEach(function(classifier) {
      results = results.concat(tracking.ViolaJones.detect(pixels, width, height, self.getInitialScale(), self.getScaleFactor(), self.getStepSize(), self.getEdgesDensity(), classifier));
    });

    this.emit('track', {
      data: results
    });
  };

  /**
   * Sets the tracker HAAR classifiers.
   * @param {TypedArray.<number>} classifiers
   */
  tracking.ObjectTracker.prototype.setClassifiers = function(classifiers) {
    this.classifiers = classifiers;
  };

  /**
   * Sets the edges density.
   * @param {number} edgesDensity
   */
  tracking.ObjectTracker.prototype.setEdgesDensity = function(edgesDensity) {
    this.edgesDensity = edgesDensity;
  };

  /**
   * Sets the initial scale to start the block scaling.
   * @param {number} initialScale
   */
  tracking.ObjectTracker.prototype.setInitialScale = function(initialScale) {
    this.initialScale = initialScale;
  };

  /**
   * Sets the scale factor to scale the feature block.
   * @param {number} scaleFactor
   */
  tracking.ObjectTracker.prototype.setScaleFactor = function(scaleFactor) {
    this.scaleFactor = scaleFactor;
  };

  /**
   * Sets the block step size.
   * @param {number} stepSize
   */
  tracking.ObjectTracker.prototype.setStepSize = function(stepSize) {
    this.stepSize = stepSize;
  };

}());



function Segmentation(img, options) {
    
    this.imgIn = img;
    this.options = options;
    
};

Segmentation.prototype.setImage = function(img){
    
    this.imgIn = img;
};

/*
function setPixel(imageData, x, y, r, g, b, a) {
    var index = (x + y * imageData.width) * 4;
    imageData.data[index+0] = r;
    imageData.data[index+1] = g;
    imageData.data[index+2] = b;
    imageData.data[index+3] = a;
}
*/

Segmentation.prototype.extractCarsTest = function(){
   
    console.log("extractCars");

    var canvas = document.createElement('canvas');
    canvas.width = 256;  // CANVAS SIZE IS IMPORTANT 
    canvas.height = 256;
    var context = canvas.getContext('2d');
    context.drawImage(this.imgIn, 0, 0, 256, 256 );
    var imgData = context.getImageData(0, 0, 256, 256);
    var pixels = imgData.data;

    var dataMap = new Uint8Array(4*256*256);
  
    for(var i = 0; i < pixels.length; i+=4){
        // dataMap[i] = pixels[i];
        
        var r = 255 - pixels[i];
        var g = 255 - pixels[i + 1];
        var b = 255 - pixels[i + 2];
        var a = pixels[i + 3];

        dataMap[i] = r;
        dataMap[i + 1] = g;
        dataMap[i + 2] = b;
        dataMap[i + 3] = a;
    }
    
    var texture = new THREE.DataTexture( dataMap/*newImage.data*/, 256, 256, THREE.RGBAFormat );
    texture.flipY = true;  // FALSE by default on THREE.DataTexture but True by default for THREE.Texture!
    texture.needsUpdate = true;
 
    return texture; 
};


Segmentation.prototype.extractCars = function(){
                    console.log("segmentation");
    
    var width = 256;
    var height = 256;
    //var colors = new tracking.ColorTracker(['magenta', 'cyan', 'yellow']);
  //  console.log("tracking", tracking);
    tracking.Fast.THRESHOLD = 25;
    
  //  console.log("extractCars");

    var canvas = document.createElement('canvas');
    canvas.width = 256;  // CANVAS SIZE IS IMPORTANT 
    canvas.height = 256;
    var context = canvas.getContext('2d');
    context.drawImage(this.imgIn, 0, 0, 256, 256 );
    
    var imageData = context.getImageData(0, 0, 256, 256);
    //console.log(this.imgIn);
  //  
    
    
 /*   
    // ***************************** CORNERS
    var gray = tracking.Image.grayscale(imageData.data, width, height);
    var corners = tracking.Fast.findCorners(gray, width, height);
    for (var i = 0; i < corners.length; i += 2) {
      context.fillStyle = '#f00';
      context.fillRect(corners[i], corners[i + 1], 3, 3);
    }
 */   


/*
   
    // ******************************** SOBEL 
    //var edges = tracking.Image.sobel(gray, width, height);
    // Sobel constructor returns an Uint8ClampedArray with sobel data
    var sobelData = Sobel(imageData);
    var sobelImageData = sobelData.toImageData();
    context.putImageData(sobelImageData, 0, 0);
 
*/    
    
    
    
    
    // ****************************** VIOLA AND JONES CARS
    var initialScale = 1;
    var scaleFactor = 1.1;
    var stepSize = 1.5;
    var edgesDensity = 0.5;
    var rectangles = tracking.ViolaJones.detect(imageData.data, width, height, initialScale, scaleFactor, stepSize, edgesDensity, json);//jsonFile);// "Processing/vj_classifier_40_20.json");
    //console.log(rectangles);
    
  /* 
    // Display results
    for (var i = 0; i < rectangles.length; i++ ){
        var rect = rectangles[i];
        context.fillStyle = 'rgba(255, 0, 0, 0.4)';
        context.fillRect(rect.x, rect.y, rect.width, rect.height);
    }
   */
  
    // Set value class and direction to alpha channel for shader 
    var PI2 = Math.PI * 2;
    for (var i = 0; i < rectangles.length; i++ ){
        var rect = rectangles[i];
        var angle = 0; // In reality the angle of the road we should have computed before in Rad [0 - 2PI]
        var classType = 1; // 0 no detection object ,1 -> cars, 2-> trees, ...  
        var alpha = classType/10 + (angle / PI2) * 0.9;  // ugly for test. Should play directly with bits 2 for class , 6 for angle
        // Temporary random for handling different car speed
        //var alpha = Math.random() * 0.9;
        var p = context.getImageData(rect.x, rect.y, rect.width, rect.height);
        var d  = p.data;  
        // Loop over each pixel and invert the color.
        for (var i = 0, n = d.length; i < n; i += 4) {
            d[i+3] = alpha * 255;
        }
        context.putImageData( p, rect.x, rect.y );   
        
        
       // context.fillStyle = 'rgba(0, 0, 0, ' + alpha + ')';
       // context.fillRect(rect.x, rect.y, rect.width, rect.height);

    }
   
   
   
   

    //   var texture = new THREE.DataTexture(dataMap, 256, 256, THREE.RGBAFormat );
    var texture = new THREE.Texture(canvas);
    texture.flipY = true;  // FALSE by default on THREE.DataTexture but True by default for THREE.Texture!
    texture.needsUpdate = true;

    return texture;
    
};


export default Segmentation;
    /*eslint-enable */